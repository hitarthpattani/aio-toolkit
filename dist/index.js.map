{"version":3,"sources":["../src/index.ts","../src/framework/runtime-action/index.ts","../src/framework/runtime-action/types.ts","../src/framework/runtime-action/response/index.ts","../src/framework/runtime-action/parameters/index.ts","../src/framework/runtime-action/validator/index.ts","../src/framework/event-consumer-action/index.ts","../src/framework/graphql-action/index.ts","../src/framework/webhook-action/index.ts","../src/framework/webhook-action/response/types.ts","../src/framework/webhook-action/response/index.ts","../src/framework/webhook-action/types.ts","../src/framework/openwhisk/index.ts","../src/framework/openwhisk-action/index.ts","../src/integration/bearer-token/index.ts","../src/integration/rest-client/index.ts","../src/commerce/adobe-auth/index.ts","../src/commerce/adobe-commerce-client/index.ts","../src/io-events/types.ts","../src/io-events/provider/list/index.ts","../src/io-events/provider/get/index.ts","../src/io-events/provider/create/index.ts","../src/io-events/provider/delete/index.ts","../src/io-events/provider/index.ts","../src/io-events/event-metadata/list/index.ts","../src/io-events/event-metadata/get/index.ts","../src/io-events/event-metadata/create/index.ts","../src/io-events/event-metadata/delete/index.ts","../src/io-events/event-metadata/index.ts","../src/io-events/registration/create/index.ts","../src/io-events/registration/delete/index.ts","../src/io-events/registration/get/index.ts","../src/io-events/registration/list/index.ts","../src/io-events/registration/index.ts"],"sourcesContent":["/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\n/**\n * App utilities and features for Adobe Commerce AIO Toolkit\n */\n\n// Export Framework utilities\nexport * from './framework';\n\n// Export Integration utilities\nexport * from './integration';\n\n// Export Commerce utilities\nexport * from './commerce';\n\n// Export I/O Events utilities\nexport * from './io-events';\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport { Core } from '@adobe/aio-sdk';\n\nimport RuntimeActionResponse from './response';\nimport Parameters from './parameters';\nimport Validator from './validator';\n\nimport { HttpStatus, HttpMethod } from './types';\nimport { RuntimeActionResponseType } from './response/types';\n\nclass RuntimeAction {\n  /**\n   * @param name\n   * @param httpMethods\n   * @param requiredParams\n   * @param requiredHeaders\n   * @param action\n   * @returns {(function(*): Promise<any>)|*}\n   */\n  static execute(\n    name: string = 'main',\n    httpMethods: HttpMethod[] = [],\n    requiredParams: string[] = [],\n    requiredHeaders: string[] = [],\n    action: (\n      params: { [key: string]: any },\n      ctx: { logger: any; headers: { [key: string]: any } }\n    ) => Promise<RuntimeActionResponseType> = async (\n      _params\n    ): Promise<RuntimeActionResponseType> => {\n      return { statusCode: HttpStatus.OK, body: {} };\n    }\n  ): (params: { [key: string]: any }) => Promise<RuntimeActionResponseType> {\n    return async (params: { [key: string]: any }) => {\n      // create a Logger\n      const logger = Core.Logger(name, { level: params.LOG_LEVEL || 'info' });\n\n      try {\n        // 'info' is the default level if not set\n        logger.info(`Calling the ${name} action`);\n\n        // log parameters, only if params.LOG_LEVEL === 'debug'\n        logger.debug(Parameters.stringify(params));\n\n        // validate request\n        const validationError = RuntimeAction.validateRequest(\n          params,\n          requiredParams,\n          requiredHeaders,\n          httpMethods,\n          logger\n        );\n        if (validationError) {\n          return validationError;\n        }\n\n        const result = await action(params, { logger: logger, headers: params.__ow_headers || {} });\n        // log the error\n        logger.info(result);\n        return result;\n      } catch (error) {\n        // log any server errors\n        logger.error(error);\n        // return with 500\n        return RuntimeActionResponse.error(HttpStatus.INTERNAL_ERROR, 'server error');\n      }\n    };\n  }\n\n  private static validateRequest(\n    params: { [key: string]: any },\n    requiredParams: string[],\n    requiredHeaders: string[],\n    httpMethods: HttpMethod[],\n    logger: any\n  ): RuntimeActionResponseType | null {\n    // check for missing request input parameters and headers\n    const errorMessage =\n      Validator.checkMissingRequestInputs(params, requiredParams, requiredHeaders) ?? '';\n    if (errorMessage) {\n      // return and log client errors\n      return RuntimeActionResponse.error(HttpStatus.BAD_REQUEST, errorMessage);\n    }\n\n    // validate HTTP method\n    const requestMethod = params.__ow_method;\n    if (httpMethods.length > 0 && !httpMethods.includes(requestMethod)) {\n      const errorMessage = `Invalid HTTP method: ${requestMethod}. Allowed methods are: ${httpMethods.join(', ')}`;\n      logger.error(errorMessage);\n      return RuntimeActionResponse.error(HttpStatus.METHOD_NOT_ALLOWED, errorMessage);\n    }\n\n    return null;\n  }\n}\n\nexport default RuntimeAction;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nexport enum HttpStatus {\n  OK = 200,\n  BAD_REQUEST = 400,\n  UNAUTHORIZED = 401,\n  NOT_FOUND = 404,\n  METHOD_NOT_ALLOWED = 405,\n  INTERNAL_ERROR = 500,\n}\n\nexport enum HttpMethod {\n  GET = 'get',\n  POST = 'post',\n  PUT = 'put',\n  DELETE = 'delete',\n  PATCH = 'patch',\n  HEAD = 'head',\n  OPTIONS = 'options',\n}\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport { HttpStatus } from '../types';\nimport { SuccessResponse, ErrorResponse } from './types';\n\nclass RuntimeActionResponse {\n  /**\n   * Returns a success response object, this method should be called on the handlers actions\n   *\n   * @param response a descriptive message of the result\n   *        e.g. 'missing xyz parameter'\n   * @param headers optional headers to include in the response\n   * @returns the response object, ready to be returned from the action main's function.\n   */\n  static success(\n    response: object | string,\n    headers: { [key: string]: string } = {}\n  ): SuccessResponse {\n    return {\n      statusCode: HttpStatus.OK,\n      body: response,\n      headers: headers,\n    };\n  }\n\n  /**\n   * Returns an error response object, this method should be called on the handlers actions\n   *\n   * @param statusCode the status code.\n   *        e.g. 400\n   * @param error a descriptive message of the result\n   *        e.g. 'missing xyz parameter'\n   * @returns the response object, ready to be returned from the action main's function.\n   */\n  static error(statusCode: HttpStatus, error: string): ErrorResponse {\n    return {\n      error: {\n        statusCode,\n        body: {\n          error: error,\n        },\n      },\n    };\n  }\n}\n\nexport default RuntimeActionResponse;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nclass Parameters {\n  /**\n   * Returns a log-ready string of the action input parameters.\n   * The `Authorization` header content will be replaced by '<hidden>'.\n   *\n   * @param params action input parameters.\n   *\n   * @returns string\n   */\n  static stringify(params: { [key: string]: any }): string {\n    // hide authorization token without overriding params\n    let headers = params.__ow_headers || {};\n    if (headers.authorization) {\n      headers = { ...headers, authorization: '<hidden>' };\n    }\n    return JSON.stringify({ ...params, __ow_headers: headers });\n  }\n}\n\nexport default Parameters;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nclass Validator {\n  /**\n   * Returns the list of missing keys given an object and its required keys.\n   * A parameter is missing if its value is undefined or ''.\n   * A value of 0 or null is not considered as missing.\n   *\n   * @param obj object to check.\n   * @param required list of required keys.\n   *        Each element can be multi-level deep using a '.' separator e.g. 'myRequiredObj.myRequiredKey'\n   *\n   * @returns array\n   * @private\n   */\n  static getMissingKeys(obj: { [key: string]: any }, required: string[]): string[] {\n    return required.filter(r => {\n      const splits = r.split('.');\n      const last = splits[splits.length - 1];\n      const traverse = splits.slice(0, -1).reduce((tObj, split) => tObj[split] || {}, obj);\n      return last && (traverse[last] === undefined || traverse[last] === ''); // missing default params are empty string\n    });\n  }\n\n  /**\n   * Returns the list of missing keys given an object and its required keys.\n   * A parameter is missing if its value is undefined or ''.\n   * A value of 0 or null is not considered as missing.\n   *\n   * @param params action input parameters.\n   * @param requiredHeaders list of required input headers.\n   * @param requiredParams list of required input parameters.\n   *        Each element can be multi-level deep using a '.' separator e.g. 'myRequiredObj.myRequiredKey'.\n   *\n   * @returns string|null if the return value is not null, then it holds an error message describing the missing inputs.\n   *\n   */\n  static checkMissingRequestInputs(\n    params: { [key: string]: any },\n    requiredParams: string[] = [],\n    requiredHeaders: string[] = []\n  ): string | null {\n    let errorMessage: string | null = null;\n\n    // input headers are always lowercase\n    requiredHeaders = requiredHeaders.map(h => h.toLowerCase());\n    // normalize header keys to lowercase for case-insensitive comparison\n    const normalizedHeaders = Object.keys(params.__ow_headers || {}).reduce(\n      (acc, key) => {\n        acc[key.toLowerCase()] = params.__ow_headers?.[key];\n        return acc;\n      },\n      {} as { [key: string]: any }\n    );\n    // check for missing headers\n    const missingHeaders = Validator.getMissingKeys(normalizedHeaders, requiredHeaders);\n    if (missingHeaders.length > 0) {\n      errorMessage = `missing header(s) '${missingHeaders.join(', ')}'`;\n    }\n\n    // check for missing parameters\n    const missingParams = Validator.getMissingKeys(params, requiredParams);\n    if (missingParams.length > 0) {\n      if (errorMessage) {\n        errorMessage += ' and ';\n      } else {\n        errorMessage = '';\n      }\n      errorMessage += `missing parameter(s) '${missingParams.join(', ')}'`;\n    }\n\n    return errorMessage;\n  }\n}\n\nexport default Validator;\n","/**\n * Adobe App Builder Event Consumer Action handler\n *\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport { Core } from '@adobe/aio-sdk';\n\nimport RuntimeActionResponse from '../runtime-action/response';\nimport Parameters from '../runtime-action/parameters';\nimport Validator from '../runtime-action/validator';\n\nimport { HttpStatus } from '../runtime-action/types';\nimport { RuntimeActionResponseType } from '../runtime-action/response/types';\n\nclass EventConsumerAction {\n  /**\n   * @param name\n   * @param requiredParams\n   * @param requiredHeaders\n   * @param action\n   * @returns {(function(*): Promise<any>)|*}\n   */\n  static execute(\n    name: string = 'main',\n    requiredParams: string[] = [],\n    requiredHeaders: string[] = [],\n    action: (\n      params: { [key: string]: any },\n      ctx: { logger: any; headers: { [key: string]: any } }\n    ) => Promise<RuntimeActionResponseType> = async (\n      _params\n    ): Promise<RuntimeActionResponseType> => {\n      return { statusCode: HttpStatus.OK, body: {} };\n    }\n  ): (params: { [key: string]: any }) => Promise<RuntimeActionResponseType> {\n    return async (params: { [key: string]: any }) => {\n      // create a Logger\n      const logger = Core.Logger(name, { level: params.LOG_LEVEL || 'info' });\n\n      try {\n        // 'info' is the default level if not set\n        logger.info(`Calling the ${name} action`);\n\n        // log parameters, only if params.LOG_LEVEL === 'debug'\n        logger.debug(Parameters.stringify(params));\n\n        // check for missing request input parameters and headers\n        const errorMessage =\n          Validator.checkMissingRequestInputs(params, requiredParams, requiredHeaders) || '';\n        if (errorMessage) {\n          // return and log client errors\n          return RuntimeActionResponse.error(HttpStatus.BAD_REQUEST, errorMessage);\n        }\n\n        const result = await action(params, { logger: logger, headers: params.__ow_headers || {} });\n        // log the error\n        logger.info(result);\n        return result;\n      } catch (error) {\n        // log any server errors\n        logger.error(error);\n        // return with 500\n        return RuntimeActionResponse.error(HttpStatus.INTERNAL_ERROR, 'server error');\n      }\n    };\n  }\n}\n\nexport default EventConsumerAction;\n","/**\n * Adobe App Builder GraphQL framework utilities\n *\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport { graphql, buildSchema, parse, validate } from 'graphql';\n\nimport RuntimeAction from '../runtime-action';\nimport RuntimeActionResponse from '../runtime-action/response';\n\nimport { HttpMethod, HttpStatus } from '../runtime-action/types';\nimport { RuntimeActionResponseType } from '../runtime-action/response/types';\n\nclass GraphQlAction {\n  static execute(\n    schema: string = `\n      type Query {\n        hello: String\n      }\n    `,\n    resolvers: (ctx: {\n      logger: any;\n      headers: { [key: string]: any };\n      params: { [key: string]: any };\n    }) => Promise<any> = async (_params): Promise<any> => {\n      return {\n        hello: (): string => 'Hello World!',\n      };\n    },\n    name: string = 'main',\n    disableIntrospection: boolean = false\n  ): (params: { [key: string]: any }) => Promise<RuntimeActionResponseType> {\n    return RuntimeAction.execute(\n      `graphql-${name}`,\n      [HttpMethod.GET, HttpMethod.POST],\n      ['query'],\n      [],\n      async (params, ctx) => {\n        let graphqlSchema;\n        try {\n          graphqlSchema = buildSchema(schema);\n        } catch (error) {\n          return RuntimeActionResponse.error(HttpStatus.BAD_REQUEST, (error as Error).message);\n        }\n        const graphqlResolvers = await resolvers({\n          ...ctx,\n          ...{\n            params,\n          },\n        });\n\n        const context = {};\n        const query = params.query;\n\n        let parsedQuery;\n        try {\n          parsedQuery = parse(query);\n        } catch (error) {\n          return RuntimeActionResponse.error(HttpStatus.BAD_REQUEST, (error as Error).message);\n        }\n\n        const validationErrors = validate(graphqlSchema, parsedQuery);\n        if (validationErrors.length) {\n          return RuntimeActionResponse.error(\n            HttpStatus.BAD_REQUEST,\n            validationErrors.map(err => err.message).join(', ')\n          );\n        }\n\n        if (disableIntrospection) {\n          // Check for introspection queries\n          const isIntrospectionQuery = parsedQuery.definitions.some((definition: any) =>\n            definition.selectionSet.selections.some((selection: any) =>\n              selection.name.value.startsWith('__')\n            )\n          );\n          if (isIntrospectionQuery) {\n            // return and log client errors\n            return RuntimeActionResponse.error(\n              HttpStatus.BAD_REQUEST,\n              'Introspection is disabled for security reasons.'\n            );\n          }\n        }\n\n        const variables =\n          typeof params.variables === 'string' ? JSON.parse(params.variables) : params.variables;\n\n        return RuntimeActionResponse.success(\n          await graphql({\n            schema: graphqlSchema,\n            source: query,\n            rootValue: graphqlResolvers,\n            contextValue: context,\n            variableValues: variables,\n            operationName: params.operationName,\n          })\n        );\n      }\n    );\n  }\n}\n\nexport default GraphQlAction;\n","/**\n * Adobe App Builder Webhook handler\n *\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport * as crypto from 'crypto';\nimport { Verify } from 'crypto';\n\nimport WebhookActionResponse from './response';\n\nimport RuntimeAction from '../runtime-action';\nimport RuntimeActionResponse from '../runtime-action/response';\nimport Parameters from '../runtime-action/parameters';\nimport Validator from '../runtime-action/validator';\n\nimport { HttpMethod, HttpStatus } from '../runtime-action/types';\nimport { SignatureVerification } from './types';\nimport { RuntimeActionResponseType } from '../runtime-action/response/types';\n\nclass WebhookAction {\n  /**\n   * @param name\n   * @param requiredParams\n   * @param requiredHeaders\n   * @param signatureVerification\n   * @param action\n   * @returns {(function(*): Promise<any>)|*}\n   */\n  static execute(\n    name: string = 'main',\n    requiredParams: string[] = [],\n    requiredHeaders: string[] = ['Authorization'],\n    signatureVerification: SignatureVerification = SignatureVerification.DISABLED,\n    action: (\n      params: { [key: string]: any },\n      ctx: { logger: any; headers: { [key: string]: any } }\n    ) => Promise<RuntimeActionResponseType> = async (\n      _params\n    ): Promise<RuntimeActionResponseType> => {\n      return { statusCode: HttpStatus.OK, body: {} };\n    }\n  ): (params: { [key: string]: any }) => Promise<RuntimeActionResponseType> {\n    return RuntimeAction.execute(\n      `webhook-${name}`,\n      [HttpMethod.GET, HttpMethod.POST],\n      [],\n      [],\n      async (params, ctx) => {\n        const operations = [];\n\n        if (params.__ow_body !== null) {\n          let payload = {};\n          try {\n            payload = JSON.parse(atob(params.__ow_body));\n          } catch {\n            // Ignore parsing errors\n          }\n          params = {\n            ...params,\n            ...payload,\n          };\n          // log parameters, only if params.LOG_LEVEL === 'debug'\n          ctx.logger.debug(Parameters.stringify(payload));\n        }\n\n        if (signatureVerification !== SignatureVerification.DISABLED) {\n          if (params.PUBLIC_KEY === undefined) {\n            operations.push(\n              WebhookActionResponse.exception(\n                'Magento\\\\Framework\\\\Exception\\\\LocalizedException',\n                'The public key is invalid'\n              )\n            );\n          } else {\n            // check for missing request input parameters and headers\n            const errorMessage: string =\n              Validator.checkMissingRequestInputs(params, requiredParams, requiredHeaders) || '';\n            if (errorMessage) {\n              // return and log client errors\n              return RuntimeActionResponse.error(HttpStatus.BAD_REQUEST, errorMessage);\n            }\n\n            const signature: any = params.__ow_headers['x-adobe-commerce-webhook-signature'] || '';\n            const verifier: Verify = crypto.createVerify('SHA256');\n            verifier.update(params.__ow_body);\n\n            let publicKey: string = params.PUBLIC_KEY;\n            if (signatureVerification === SignatureVerification.ENABLED_WITH_BASE64) {\n              publicKey = atob(publicKey);\n            }\n\n            const isSignatureValid = verifier.verify(publicKey, signature, 'base64');\n\n            if (isSignatureValid) {\n              operations.push(await action(params, ctx));\n            } else {\n              operations.push(\n                WebhookActionResponse.exception(\n                  'Magento\\\\Framework\\\\Exception\\\\LocalizedException',\n                  `The signature is invalid.`\n                )\n              );\n            }\n          }\n        } else {\n          // check for missing request input parameters and headers\n          const errorMessage: string =\n            Validator.checkMissingRequestInputs(params, requiredParams, requiredHeaders) || '';\n          if (errorMessage) {\n            // return and log client errors\n            return RuntimeActionResponse.error(HttpStatus.BAD_REQUEST, errorMessage);\n          }\n\n          operations.push(await action(params, ctx));\n        }\n\n        return RuntimeActionResponse.success(JSON.stringify(operations));\n      }\n    );\n  }\n}\n\nexport default WebhookAction;\n","/**\n * Adobe App Builder Webhook Response types and interfaces\n *\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nexport enum WebhookOperation {\n  SUCCESS = 'success',\n  EXCEPTION = 'exception',\n  ADD = 'add',\n  REPLACE = 'replace',\n  REMOVE = 'remove',\n}\n\nexport interface SuccessResponse {\n  op: typeof WebhookOperation.SUCCESS;\n}\n\nexport interface ExceptionResponse {\n  op: typeof WebhookOperation.EXCEPTION;\n  class?: string | undefined;\n  message?: string | undefined;\n}\n\nexport interface AddResponse {\n  op: typeof WebhookOperation.ADD;\n  path: string;\n  value: any;\n  instance?: string | undefined;\n}\n\nexport interface ReplaceResponse {\n  op: typeof WebhookOperation.REPLACE;\n  path: string;\n  value: any;\n  instance?: string | undefined;\n}\n\nexport interface RemoveResponse {\n  op: typeof WebhookOperation.REMOVE;\n  path: string;\n}\n","/**\n * Adobe App Builder Webhook Response utilities\n *\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport {\n  WebhookOperation,\n  SuccessResponse,\n  ExceptionResponse,\n  AddResponse,\n  ReplaceResponse,\n  RemoveResponse,\n} from './types';\n\nclass WebhookActionResponse {\n  static success(): SuccessResponse {\n    return {\n      op: WebhookOperation.SUCCESS,\n    };\n  }\n\n  static exception(exceptionClass?: string, message?: string): ExceptionResponse {\n    return {\n      op: WebhookOperation.EXCEPTION,\n      class: exceptionClass,\n      message: message,\n    };\n  }\n\n  static add(path: string, value: any, instance?: string): AddResponse {\n    return {\n      op: WebhookOperation.ADD,\n      path: path,\n      value: value,\n      instance: instance,\n    };\n  }\n\n  static replace(path: string, value: any, instance?: string): ReplaceResponse {\n    return {\n      op: WebhookOperation.REPLACE,\n      path: path,\n      value: value,\n      instance: instance,\n    };\n  }\n\n  static remove(path: string): RemoveResponse {\n    return {\n      op: WebhookOperation.REMOVE,\n      path: path,\n    };\n  }\n}\n\nexport default WebhookActionResponse;\n","/**\n * Adobe App Builder Webhook types and enums\n *\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nexport enum SignatureVerification {\n  DISABLED = 0,\n  ENABLED = 1,\n  ENABLED_WITH_BASE64 = 2,\n}\n","/**\n * Adobe App Builder OpenWhisk client wrapper\n *\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport openwhisk, { Activation, Dict } from 'openwhisk';\n\nclass Openwhisk {\n  /**\n   * @var openwhisk\n   */\n  openwhiskClient: ReturnType<typeof openwhisk>;\n\n  /**\n   * @param host\n   * @param apiKey\n   */\n  constructor(host: string, apiKey: string) {\n    this.openwhiskClient = openwhisk({ apihost: host, api_key: apiKey });\n  }\n\n  /**\n   * @param action\n   * @param params\n   * @returns {Promise<Activation<Dict>>}\n   */\n  async execute(action: string, params: Dict): Promise<Activation<Dict>> {\n    return await this.openwhiskClient.actions.invoke({\n      name: action,\n      blocking: true,\n      params: params,\n    });\n  }\n}\n\nexport default Openwhisk;\n","/**\n * Adobe App Builder OpenWhisk Action handler\n *\n * Copyright © Adobe, Inc. All rights reserved.\n */\n// OpenWhisk action handler - no direct client dependency needed\n\nimport { Core } from '@adobe/aio-sdk';\n\nimport RuntimeActionResponse from '../runtime-action/response';\nimport Parameters from '../runtime-action/parameters';\n\nimport { HttpStatus } from '../runtime-action/types';\nimport { RuntimeActionResponseType } from '../runtime-action/response/types';\n\nclass OpenwhiskAction {\n  /**\n   * @param name\n   * @param action\n   * @returns {(function(*): Promise<any>)|*}\n   */\n  static execute(\n    name: string = 'main',\n    action: (\n      params: { [key: string]: any },\n      ctx: { logger: any; headers: { [key: string]: any } }\n    ) => Promise<RuntimeActionResponseType> = async (\n      _params\n    ): Promise<RuntimeActionResponseType> => {\n      return { statusCode: HttpStatus.OK, body: {} };\n    }\n  ): (params: { [key: string]: any }) => Promise<RuntimeActionResponseType> {\n    return async (params: { [key: string]: any }) => {\n      // create a Logger\n      const logger = Core.Logger(name, { level: params.LOG_LEVEL || 'info' });\n\n      try {\n        // 'info' is the default level if not set\n        logger.info(`Calling the ${name} webhook action`);\n\n        // log parameters, only if params.LOG_LEVEL === 'debug'\n        logger.debug(Parameters.stringify(params));\n\n        const result = await action(params, { logger: logger, headers: params.__ow_headers || {} });\n        // log the error\n        logger.info(result);\n        return result;\n      } catch (error) {\n        // log any server errors\n        logger.error(error);\n        // return with 500\n        return RuntimeActionResponse.error(HttpStatus.INTERNAL_ERROR, 'server error');\n      }\n    };\n  }\n}\n\nexport default OpenwhiskAction;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\n/**\n * Utility class for extracting and handling Bearer tokens from OpenWhisk action parameters\n */\nclass BearerToken {\n  /**\n   * Extracts the Bearer token from OpenWhisk action parameters.\n   * Looks for the authorization header in __ow_headers and extracts the token value\n   * after the \"Bearer \" prefix.\n   *\n   * @param params - OpenWhisk action input parameters containing headers\n   * @returns The Bearer token string if found, undefined otherwise\n   *\n   * @example\n   * const params = {\n   *   __ow_headers: {\n   *     authorization: 'Bearer abc123token'\n   *   }\n   * };\n   * const token = BearerToken.extract(params); // returns 'abc123token'\n   */\n  static extract(params: { [key: string]: any }): string | undefined {\n    if (params.__ow_headers?.authorization?.startsWith('Bearer ')) {\n      return params.__ow_headers.authorization.substring('Bearer '.length);\n    }\n    return undefined;\n  }\n}\n\nexport default BearerToken;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport fetch, { RequestInit, Response } from 'node-fetch';\nimport { Headers } from './types';\n\nclass RestClient {\n  /**\n   * A generic method to make GET rest call\n   *\n   * @param endpoint\n   * @param headers\n   * @returns {Promise<any>}\n   */\n  async get(endpoint: string, headers: Headers = {}): Promise<any> {\n    return await this.apiCall(endpoint, 'GET', headers);\n  }\n\n  /**\n   * A generic method to make POST rest call\n   *\n   * @param endpoint\n   * @param headers\n   * @param payload\n   * @returns {Promise<any>}\n   */\n  async post(endpoint: string, headers: Headers = {}, payload: any = null): Promise<any> {\n    return await this.apiCall(endpoint, 'POST', headers, payload);\n  }\n\n  /**\n   * A generic method to make PUT rest call\n   *\n   * @param endpoint\n   * @param headers\n   * @param payload\n   * @returns {Promise<any>}\n   */\n  async put(endpoint: string, headers: Headers = {}, payload: any = null): Promise<any> {\n    return await this.apiCall(endpoint, 'PUT', headers, payload);\n  }\n\n  /**\n   * A generic method to make DELETE rest call\n   *\n   * @param endpoint\n   * @param headers\n   * @returns {Promise<any>}\n   */\n  async delete(endpoint: string, headers: Headers = {}): Promise<any> {\n    return await this.apiCall(endpoint, 'DELETE', headers);\n  }\n\n  /**\n   * A generic method to make rest call\n   *\n   * @param endpoint\n   * @param method\n   * @param headers\n   * @param payload\n   * @returns {Promise<any>}\n   */\n  async apiCall(\n    endpoint: string,\n    method: string = 'POST',\n    headers: Headers = {},\n    payload: any = null\n  ): Promise<any> {\n    let options: RequestInit = {\n      method: method,\n      headers: headers,\n    };\n\n    if (payload !== null) {\n      options = {\n        ...options,\n        body: JSON.stringify(payload),\n        headers: {\n          ...headers,\n          'Content-Type': 'application/json',\n        },\n      };\n    }\n\n    const response: Response = await fetch(endpoint, options);\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    // Handle responses with no content (like 204 No Content)\n    if (response.status === 204 || response.headers?.get('content-length') === '0') {\n      return null;\n    }\n\n    // Try JSON first (for both real responses and mocked responses)\n    if (typeof response.json === 'function') {\n      const contentType = response.headers?.get('content-type');\n      // If no content-type header (mocked response) or JSON content-type, parse as JSON\n      if (\n        !contentType ||\n        contentType.includes('application/json') ||\n        contentType.includes('application/hal+json')\n      ) {\n        return await response.json();\n      }\n    }\n\n    // For non-JSON responses, return text\n    if (typeof response.text === 'function') {\n      const text = await response.text();\n      return text;\n    }\n\n    // Fallback for responses without text/json methods\n    return null;\n  }\n}\n\nexport default RestClient;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport { context, getToken } from '@adobe/aio-lib-ims';\nimport { AdobeIMSConfig } from './types';\n\n/**\n * Class providing authentication functionality for Adobe IMS (Identity Management System)\n */\nclass AdobeAuth {\n  /**\n   * Retrieves an authentication token from Adobe IMS\n   *\n   * @param clientId - The client ID for the Adobe IMS integration\n   * @param clientSecret - The client secret for the Adobe IMS integration\n   * @param technicalAccountId - The technical account ID for the Adobe IMS integration\n   * @param technicalAccountEmail - The technical account email for the Adobe IMS integration\n   * @param imsOrgId - The IMS organization ID\n   * @param scopes - Array of permission scopes to request for the token\n   * @param currentContext - The context name for storing the configuration (defaults to 'onboarding-config')\n   * @returns Promise<string> - A promise that resolves to the authentication token\n   *\n   * @example\n   * const token = await AdobeAuth.getToken(\n   *   'your-client-id',\n   *   'your-client-secret',\n   *   'your-technical-account-id',\n   *   'your-technical-account-email',\n   *   'your-ims-org-id',\n   *   ['AdobeID', 'openid', 'adobeio_api']\n   * );\n   */\n  static async getToken(\n    clientId: string,\n    clientSecret: string,\n    technicalAccountId: string,\n    technicalAccountEmail: string,\n    imsOrgId: string,\n    scopes: string[],\n    currentContext: string = 'onboarding-config'\n  ): Promise<string> {\n    const config: AdobeIMSConfig = {\n      client_id: clientId,\n      client_secrets: [clientSecret],\n      technical_account_id: technicalAccountId,\n      technical_account_email: technicalAccountEmail,\n      ims_org_id: imsOrgId,\n      scopes: scopes,\n    };\n\n    await context.setCurrent(currentContext);\n    await context.set(currentContext, config);\n\n    return await getToken();\n  }\n}\n\nexport default AdobeAuth;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport { Core } from '@adobe/aio-sdk';\nimport got, { Got } from 'got';\n\nimport { HttpStatus } from '../../framework/runtime-action/types';\nimport { Connection, ExtendedRequestError } from './types';\n\nclass AdobeCommerceClient {\n  private baseUrl: string;\n  private connection: Connection;\n  private logger: any;\n\n  /**\n   * @param baseUrl\n   * @param connection\n   * @param logger\n   */\n  constructor(baseUrl: string, connection: Connection, logger: any = null) {\n    if (!baseUrl) {\n      throw new Error('Commerce URL must be provided');\n    }\n    this.baseUrl = baseUrl;\n    this.connection = connection;\n\n    if (logger === null) {\n      logger = Core.Logger('adobe-commerce-client', {\n        level: 'debug',\n      });\n    }\n    this.logger = logger;\n  }\n\n  /**\n   * @param endpoint\n   * @param headers\n   */\n  async get(endpoint: string, headers: Record<string, string> = {}): Promise<any> {\n    return await this.apiCall(endpoint, 'GET', headers);\n  }\n\n  /**\n   * @param endpoint\n   * @param headers\n   * @param payload\n   */\n  async post(\n    endpoint: string,\n    headers: Record<string, string> = {},\n    payload: any = null\n  ): Promise<any> {\n    return await this.apiCall(endpoint, 'POST', headers, payload);\n  }\n\n  /**\n   * @param endpoint\n   * @param headers\n   * @param payload\n   */\n  async put(\n    endpoint: string,\n    headers: Record<string, string> = {},\n    payload: any = null\n  ): Promise<any> {\n    return await this.apiCall(endpoint, 'PUT', headers, payload);\n  }\n\n  /**\n   * @param endpoint\n   * @param headers\n   */\n  async delete(endpoint: string, headers: Record<string, string> = {}): Promise<any> {\n    return await this.apiCall(endpoint, 'DELETE', headers);\n  }\n\n  /**\n   * @param endpoint\n   * @param method\n   * @param headers\n   * @param payload\n   * @private\n   */\n  private async apiCall(\n    endpoint: string,\n    method: string = 'POST',\n    headers: Record<string, string> = {},\n    payload: any = null\n  ): Promise<any> {\n    const commerceGot = await this.getHttpClient();\n\n    commerceGot.extend({\n      headers: headers,\n    });\n\n    const wrapper = async (callable: () => Promise<any>): Promise<any> => {\n      try {\n        const message = await callable();\n        return { success: true, message };\n      } catch (e: any) {\n        if (e.code === 'ERR_GOT_REQUEST_ERROR') {\n          this.logger.error('Error while calling Commerce API', e);\n          return {\n            success: false,\n            statusCode: HttpStatus.INTERNAL_ERROR,\n            message: `Unexpected error, check logs. Original error \"${e.message}\"`,\n          };\n        }\n        return {\n          success: false,\n          statusCode: e.response?.statusCode || HttpStatus.INTERNAL_ERROR,\n          message: e.message,\n          body: (e as ExtendedRequestError).responseBody,\n        };\n      }\n    };\n\n    let options: any = {\n      method: method,\n    };\n\n    if (payload !== null) {\n      options = {\n        ...options,\n        json: payload,\n      };\n    }\n\n    return await wrapper(() => commerceGot(endpoint, options).json());\n  }\n\n  /**\n   * @private\n   */\n  private async getHttpClient(): Promise<Got> {\n    const commerceGot = got.extend({\n      http2: true,\n      responseType: 'json',\n      prefixUrl: this.baseUrl,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      hooks: {\n        beforeRequest: [\n          (options): void => this.logger.debug(`Request [${options.method}] ${options.url}`),\n        ],\n        beforeRetry: [\n          (options, error, retryCount): void =>\n            this.logger.debug(\n              `Retrying request [${options.method}] ${options.url} - count: ${retryCount} - error: ${error?.code} - ${error?.message}`\n            ),\n        ],\n        beforeError: [\n          (error: ExtendedRequestError): ExtendedRequestError => {\n            const { response } = error;\n            if (response?.body) {\n              error.responseBody = response.body;\n            }\n            return error;\n          },\n        ],\n        afterResponse: [\n          (response): any => {\n            this.logger.debug(\n              `Response [${response.request.options.method}] ${response.request.options.url} - ${response.statusCode} ${response.statusMessage}`\n            );\n            return response;\n          },\n        ],\n      },\n    });\n\n    return await this.connection.extend(commerceGot);\n  }\n}\n\nexport default AdobeCommerceClient;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\n/**\n * Adobe I/O Events global constants\n */\nexport const IoEventsGlobals = {\n  BASE_URL: 'https://api.adobe.io',\n  STATUS_CODES: {\n    OK: 200,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    REQUEST_TIMEOUT: 408,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    INTERNAL_SERVER_ERROR: 500,\n  },\n  HEADERS: {\n    CONFLICTING_ID: 'x-conflicting-id',\n  },\n} as const;\n\n/**\n * HAL (Hypertext Application Language) link structure\n */\nexport interface HALLink {\n  href: string;\n  templated?: boolean;\n  type?: string;\n  title?: string;\n}\n\n/**\n * Error response from Adobe I/O Events API\n */\nexport interface IOEventsError {\n  error?: string;\n  message?: string;\n  error_code?: string;\n  details?: string;\n}\n\n/**\n * Custom error class for Adobe I/O Events API errors\n */\nexport class IOEventsApiError extends Error {\n  public readonly statusCode: number;\n  public readonly errorCode: string | undefined;\n  public readonly details: string | undefined;\n\n  constructor(message: string, statusCode: number, errorCode?: string, details?: string) {\n    super(message);\n    this.name = 'IOEventsApiError';\n    this.statusCode = statusCode;\n    this.errorCode = errorCode;\n    this.details = details;\n  }\n}\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IOEventsError, IoEventsGlobals } from '../../types';\nimport { Provider } from '../types';\nimport { ListProvidersQueryParams, ProvidersListResponse } from './types';\n\n/**\n * List providers for Adobe I/O Events\n *\n * This class handles the retrieval of event providers entitled to a specific organization ID.\n * It supports filtering by provider metadata ID, instance ID, and can optionally include\n * event metadata in the response.\n */\nclass List {\n  private readonly endpoint: string = IoEventsGlobals.BASE_URL;\n  private readonly restClient: RestClient;\n\n  /**\n   * Constructor for List providers service\n   *\n   * @param clientId - Client ID from Adobe Developer Console (x-api-key header)\n   * @param consumerId - Project Organization ID from Adobe Developer Console\n   * @param projectId - Project ID from Adobe Developer Console\n   * @param workspaceId - Workspace ID from Adobe Developer Console\n   * @param accessToken - IMS token for authentication (Bearer token)\n   */\n  constructor(\n    private readonly clientId: string,\n    private readonly consumerId: string,\n    private readonly projectId: string,\n    private readonly workspaceId: string,\n    private readonly accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new Error('clientId is required and cannot be empty');\n    }\n    if (!consumerId?.trim()) {\n      throw new Error('consumerId is required and cannot be empty');\n    }\n    if (!projectId?.trim()) {\n      throw new Error('projectId is required and cannot be empty');\n    }\n    if (!workspaceId?.trim()) {\n      throw new Error('workspaceId is required and cannot be empty');\n    }\n    if (!accessToken?.trim()) {\n      throw new Error('accessToken is required and cannot be empty');\n    }\n\n    this.restClient = new RestClient();\n  }\n\n  /**\n   * Execute the list providers API call with automatic pagination\n   *\n   * This method automatically handles pagination by following the `_links.next.href` from the HAL+JSON response.\n   * It makes recursive API calls to fetch all pages and returns a complete array containing all providers\n   * across all pages.\n   *\n   * @param queryParams - Optional query parameters for filtering providers\n   * @param queryParams.providerMetadataId - Filter by provider metadata id\n   * @param queryParams.instanceId - Filter by instance id\n   * @param queryParams.providerMetadataIds - List of provider metadata ids to filter (mutually exclusive with providerMetadataId)\n   * @param queryParams.eventmetadata - Boolean to fetch provider's event metadata (default: false)\n   * @returns Promise<Provider[]> - Complete array of all providers across all pages\n   * @throws IOEventsApiError - When API call fails with specific error details\n   */\n  async execute(queryParams: ListProvidersQueryParams = {}): Promise<Provider[]> {\n    try {\n      // Validate query parameters\n      if (queryParams.providerMetadataId && queryParams.providerMetadataIds) {\n        throw new Error('Cannot specify both providerMetadataId and providerMetadataIds');\n      }\n\n      // Build the API URL\n      const url = `${this.endpoint}/events/${this.consumerId}/providers`;\n\n      // Build query string if parameters are provided\n      const queryString = this.buildQueryString(queryParams);\n      const fullUrl = queryString ? `${url}?${queryString}` : url;\n\n      // Prepare headers as required by the API\n      const headers = {\n        Authorization: `Bearer ${this.accessToken}`,\n        'x-api-key': this.clientId,\n        Accept: 'application/hal+json',\n      };\n\n      return await this.fetchAllPages(fullUrl, headers);\n    } catch (error: any) {\n      // Handle different types of errors\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Recursively fetches all pages of providers using pagination links\n   *\n   * @param url - The URL to fetch (either initial URL or next page URL)\n   * @param headers - Headers for the API request\n   * @param accumulatedResults - Array to accumulate results across pages\n   * @returns Promise<Provider[]> - Complete array of all providers\n   * @private\n   */\n  private async fetchAllPages(\n    url: string,\n    headers: Record<string, string>,\n    accumulatedResults: Provider[] = []\n  ): Promise<Provider[]> {\n    // Make the GET request\n    const response: ProvidersListResponse = await this.restClient.get(url, headers);\n\n    // Validate response format\n    if (response === null || response === undefined) {\n      throw new Error('Invalid response format: Expected object');\n    }\n\n    if (typeof response !== 'object') {\n      throw new Error('Invalid response format: Expected object');\n    }\n\n    // Extract providers array\n    const providers = response._embedded?.providers;\n\n    if (providers !== undefined && !Array.isArray(providers)) {\n      throw new Error('Invalid response format: providers should be an array');\n    }\n\n    // Get current page results\n    const currentPageResults = providers || [];\n\n    // Accumulate results from current page\n    const allResults = [...accumulatedResults, ...currentPageResults];\n\n    // Check if there's a next page\n    const nextPageUrl = response._links?.next?.href;\n\n    if (nextPageUrl) {\n      // Recursively fetch the next page\n      return await this.fetchAllPages(nextPageUrl, headers, allResults);\n    }\n\n    // No more pages, return all accumulated results\n    return allResults;\n  }\n\n  /**\n   * Handle and transform errors from the API call\n   * @private\n   * @param error - The caught error\n   * @throws IOEventsApiError - Transformed error with proper details\n   */\n  private handleError(error: any): never {\n    // Check if it's an HTTP error from RestClient (e.g., \"HTTP error! status: 404\")\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    // Check if error has response body with error details\n    if (error.response?.body) {\n      const errorBody: IOEventsError = error.response.body;\n      const statusCode =\n        error.response.statusCode || IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n      const message =\n        errorBody.message || errorBody.error || this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(message, statusCode, errorBody.error_code, errorBody.details);\n    }\n\n    // Handle network errors\n    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {\n      throw new IOEventsApiError(\n        'Network error: Unable to connect to Adobe I/O Events API. Please check your internet connection.',\n        0,\n        'NETWORK_ERROR'\n      );\n    }\n\n    // Handle timeout errors\n    if (error.code === 'ETIMEDOUT') {\n      throw new IOEventsApiError(\n        'Request timeout: Adobe I/O Events API did not respond in time.',\n        0,\n        'TIMEOUT_ERROR'\n      );\n    }\n\n    // Handle JSON parsing errors\n    if (error.message?.includes('JSON') || error.name === 'SyntaxError') {\n      throw new IOEventsApiError(\n        'Invalid response format: Unable to parse API response.',\n        0,\n        'PARSE_ERROR'\n      );\n    }\n\n    // Handle validation errors\n    if (\n      error.message?.includes('Cannot specify both') ||\n      error.message?.includes('Invalid response format')\n    ) {\n      throw new IOEventsApiError(\n        error.message,\n        IoEventsGlobals.STATUS_CODES.BAD_REQUEST,\n        'VALIDATION_ERROR'\n      );\n    }\n\n    // Generic error fallback\n    throw new IOEventsApiError(\n      `Failed to list providers: ${error.message || 'Unknown error occurred'}`,\n      IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n      'UNKNOWN_ERROR'\n    );\n  }\n\n  /**\n   * Extracts the status code from RestClient error message\n   *\n   * @param errorMessage - Error message like \"HTTP error! status: 404\"\n   * @returns The HTTP status code\n   */\n  private extractStatusCodeFromMessage(errorMessage: string): number {\n    const match = errorMessage.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Get user-friendly error message based on HTTP status code\n   * @private\n   * @param statusCode - HTTP status code\n   * @returns string - User-friendly error message\n   */\n  private getErrorMessageForStatus(statusCode: number): string {\n    switch (statusCode) {\n      case IoEventsGlobals.STATUS_CODES.UNAUTHORIZED:\n        return 'Unauthorized: Invalid or expired access token';\n      case IoEventsGlobals.STATUS_CODES.FORBIDDEN:\n        return 'Forbidden: Insufficient permissions or invalid API key';\n      case IoEventsGlobals.STATUS_CODES.NOT_FOUND:\n        return 'Not Found: Provider associated with the consumerOrgId, providerMetadataId or instanceID does not exist';\n      case IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR:\n        return 'Internal Server Error: Adobe I/O Events service is temporarily unavailable';\n      default:\n        return `API Error: HTTP ${statusCode}`;\n    }\n  }\n\n  /**\n   * Build query string from parameters\n   * @private\n   */\n  private buildQueryString(params: ListProvidersQueryParams): string {\n    const queryParts: string[] = [];\n\n    // Add providerMetadataId if provided\n    if (params.providerMetadataId) {\n      queryParts.push(`providerMetadataId=${encodeURIComponent(params.providerMetadataId)}`);\n    }\n\n    // Add instanceId if provided\n    if (params.instanceId) {\n      queryParts.push(`instanceId=${encodeURIComponent(params.instanceId)}`);\n    }\n\n    // Add providerMetadataIds array if provided\n    if (params.providerMetadataIds && Array.isArray(params.providerMetadataIds)) {\n      params.providerMetadataIds.forEach((id: string) => {\n        queryParts.push(`providerMetadataIds=${encodeURIComponent(id)}`);\n      });\n    }\n\n    // Add eventmetadata boolean if provided\n    if (typeof params.eventmetadata === 'boolean') {\n      queryParts.push(`eventmetadata=${params.eventmetadata}`);\n    }\n\n    return queryParts.join('&');\n  }\n}\n\nexport default List;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IoEventsGlobals } from '../../types';\nimport { Provider } from '../types';\nimport { GetProviderQueryParams } from './types';\n\n/**\n * Get provider by ID for Adobe I/O Events\n *\n * This class handles the retrieval of a specific event provider by its ID.\n * It supports including event metadata in the response.\n */\nclass Get {\n  private readonly endpoint: string = IoEventsGlobals.BASE_URL;\n  private readonly restClient: RestClient;\n\n  /**\n   * Constructor for Get provider service\n   *\n   * @param clientId - Client ID from Adobe Developer Console (x-api-key header)\n   * @param consumerId - Project Organization ID from Adobe Developer Console\n   * @param projectId - Project ID from Adobe Developer Console\n   * @param workspaceId - Workspace ID from Adobe Developer Console\n   * @param accessToken - IMS token for authentication (Bearer token)\n   */\n  constructor(\n    private readonly clientId: string,\n    private readonly consumerId: string,\n    private readonly projectId: string,\n    private readonly workspaceId: string,\n    private readonly accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new Error('clientId is required and cannot be empty');\n    }\n    if (!consumerId?.trim()) {\n      throw new Error('consumerId is required and cannot be empty');\n    }\n    if (!projectId?.trim()) {\n      throw new Error('projectId is required and cannot be empty');\n    }\n    if (!workspaceId?.trim()) {\n      throw new Error('workspaceId is required and cannot be empty');\n    }\n    if (!accessToken?.trim()) {\n      throw new Error('accessToken is required and cannot be empty');\n    }\n\n    this.restClient = new RestClient();\n  }\n\n  /**\n   * Execute the get provider by ID API call\n   *\n   * @param providerId - The ID of the provider to retrieve\n   * @param queryParams - Optional query parameters\n   * @param queryParams.eventmetadata - Boolean to fetch provider's event metadata (default: false)\n   * @returns Promise<Provider> - The provider details\n   * @throws IOEventsApiError - When API call fails with specific error details\n   *\n   * @example\n   * ```typescript\n   * // Get basic provider details\n   * const provider = await getService.execute('provider-123');\n   *\n   * // Get provider details with event metadata\n   * const providerWithMetadata = await getService.execute('provider-123', {\n   *   eventmetadata: true\n   * });\n   * ```\n   */\n  async execute(providerId: string, queryParams: GetProviderQueryParams = {}): Promise<Provider> {\n    try {\n      // Validate provider ID\n      if (!providerId?.trim()) {\n        throw new Error('Provider ID is required and cannot be empty');\n      }\n\n      // Build the API URL\n      const url = `${this.endpoint}/events/providers/${encodeURIComponent(providerId)}`;\n\n      // Build query string if parameters are provided\n      const queryString = this.buildQueryString(queryParams);\n      const fullUrl = queryString ? `${url}?${queryString}` : url;\n\n      // Prepare headers as required by the API\n      const headers = {\n        Authorization: `Bearer ${this.accessToken}`,\n        'x-api-key': this.clientId,\n        Accept: 'application/hal+json',\n      };\n\n      // Make the GET request\n      const response: Provider = await this.restClient.get(fullUrl, headers);\n\n      // Validate response format\n      if (response === null || response === undefined) {\n        throw new Error('Invalid response format: Expected provider object');\n      }\n      if (typeof response !== 'object') {\n        throw new Error('Invalid response format: Expected provider object');\n      }\n\n      return response;\n    } catch (error: any) {\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Build query string from parameters\n   */\n  private buildQueryString(queryParams: GetProviderQueryParams): string {\n    const params = new URLSearchParams();\n\n    // Handle eventmetadata parameter\n    if (queryParams.eventmetadata !== undefined) {\n      params.append('eventmetadata', String(queryParams.eventmetadata));\n    }\n\n    return params.toString();\n  }\n\n  /**\n   * Handle and transform errors into IOEventsApiError\n   */\n  private handleError(error: any): never {\n    // Check if it's an HTTP error from RestClient (e.g., \"HTTP error! status: 404\")\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    // Handle HTTP errors from RestClient\n    if (error.response) {\n      const status = this.extractStatusCode(error);\n      const errorMessage = this.getErrorMessageForStatus(status);\n      throw new IOEventsApiError(errorMessage, status, 'API_ERROR');\n    }\n\n    // Handle network errors\n    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {\n      throw new IOEventsApiError(\n        'Network error: Unable to connect to Adobe I/O Events API',\n        IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n        'NETWORK_ERROR'\n      );\n    }\n\n    // Handle timeout errors\n    if (error.code === 'ETIMEDOUT') {\n      throw new IOEventsApiError(\n        'Request timeout: Adobe I/O Events API did not respond in time',\n        IoEventsGlobals.STATUS_CODES.TIMEOUT,\n        'TIMEOUT_ERROR'\n      );\n    }\n\n    // Handle JSON parsing errors\n    if (error.message?.includes('JSON')) {\n      throw new IOEventsApiError(\n        'Invalid response format from Adobe I/O Events API',\n        IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n        'PARSE_ERROR'\n      );\n    }\n\n    // Handle validation errors (from provider ID or response validation)\n    if (\n      error.message?.includes('Provider ID is required') ||\n      error.message?.includes('Invalid response format')\n    ) {\n      throw new IOEventsApiError(\n        error.message,\n        IoEventsGlobals.STATUS_CODES.BAD_REQUEST,\n        'VALIDATION_ERROR'\n      );\n    }\n\n    // Generic error fallback\n    throw new IOEventsApiError(\n      `Unexpected error: ${error.message || 'Unknown error occurred'}`,\n      IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n      'UNKNOWN_ERROR'\n    );\n  }\n\n  /**\n   * Extract status code from error response\n   */\n  private extractStatusCode(error: any): number {\n    return (\n      error.response?.status || error.status || IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR\n    );\n  }\n\n  /**\n   * Extracts the status code from RestClient error message\n   *\n   * @param errorMessage - Error message like \"HTTP error! status: 404\"\n   * @returns The HTTP status code\n   */\n  private extractStatusCodeFromMessage(errorMessage: string): number {\n    const match = errorMessage.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Get specific error message based on HTTP status code\n   */\n  private getErrorMessageForStatus(status: number): string {\n    switch (status) {\n      case IoEventsGlobals.STATUS_CODES.UNAUTHORIZED:\n        return 'Unauthorized: Invalid or expired access token';\n      case IoEventsGlobals.STATUS_CODES.FORBIDDEN:\n        return 'Forbidden: Insufficient permissions to access this provider';\n      case IoEventsGlobals.STATUS_CODES.NOT_FOUND:\n        return 'Provider ID does not exist';\n      case IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR:\n        return 'Internal server error occurred while fetching provider';\n      default:\n        return `HTTP ${status}: Provider request failed`;\n    }\n  }\n}\n\nexport default Get;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IoEventsGlobals } from '../../types';\nimport { Provider } from '../types';\nimport { ProviderInputModel } from './types';\n\n/**\n * Create provider for Adobe I/O Events\n *\n * This class handles the creation of new event providers for a specific organization,\n * project, and workspace. It supports both single-instance and multi-instance providers.\n */\nclass Create {\n  private readonly endpoint: string = IoEventsGlobals.BASE_URL;\n  private readonly restClient: RestClient;\n\n  /**\n   * Constructor for Create provider service\n   *\n   * @param clientId - Client ID from Adobe Developer Console (x-api-key header)\n   * @param consumerId - Project Organization ID from Adobe Developer Console\n   * @param projectId - Project ID from Adobe Developer Console\n   * @param workspaceId - Workspace ID from Adobe Developer Console\n   * @param accessToken - IMS token for authentication (Bearer token)\n   */\n  constructor(\n    private readonly clientId: string,\n    private readonly consumerId: string,\n    private readonly projectId: string,\n    private readonly workspaceId: string,\n    private readonly accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new Error('clientId is required and cannot be empty');\n    }\n    if (!consumerId?.trim()) {\n      throw new Error('consumerId is required and cannot be empty');\n    }\n    if (!projectId?.trim()) {\n      throw new Error('projectId is required and cannot be empty');\n    }\n    if (!workspaceId?.trim()) {\n      throw new Error('workspaceId is required and cannot be empty');\n    }\n    if (!accessToken?.trim()) {\n      throw new Error('accessToken is required and cannot be empty');\n    }\n\n    this.restClient = new RestClient();\n  }\n\n  /**\n   * Execute the create provider API call\n   *\n   * @param providerData - Provider input data\n   * @returns Promise<Provider> - The created provider\n   * @throws IOEventsApiError - When API call fails with specific error details\n   */\n  async execute(providerData: ProviderInputModel): Promise<Provider> {\n    try {\n      // Validate required parameters\n      if (!providerData) {\n        throw new Error('providerData is required');\n      }\n      if (!providerData.label?.trim()) {\n        throw new Error('label is required in providerData');\n      }\n\n      // Build the API URL\n      const url = `${this.endpoint}/events/${this.consumerId}/${this.projectId}/${this.workspaceId}/providers`;\n\n      // Prepare headers as required by the API\n      const headers = {\n        Authorization: `Bearer ${this.accessToken}`,\n        'x-api-key': this.clientId,\n        Accept: 'application/hal+json',\n        'Content-Type': 'application/json',\n      };\n\n      // Make the POST request\n      const response: Provider = await this.restClient.post(url, headers, providerData);\n\n      // Validate response format\n      if (response === null || response === undefined) {\n        throw new Error('Invalid response format: Expected provider object');\n      }\n\n      if (typeof response !== 'object') {\n        throw new Error('Invalid response format: Expected provider object');\n      }\n\n      // Validate required provider fields\n      if (!response.id) {\n        throw new Error('Invalid response format: Missing provider id');\n      }\n\n      return response;\n    } catch (error: any) {\n      // Handle different types of errors\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Handle and transform errors from the API call\n   * @private\n   * @param error - The caught error\n   * @throws IOEventsApiError - Transformed error with proper details\n   */\n  private handleError(error: any): never {\n    // Check if it's an HTTP error from RestClient (e.g., \"HTTP error! status: 404\")\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    // Check if error has response body with error details\n    if (error.response?.body) {\n      const errorBody = error.response.body;\n      const statusCode =\n        error.response.statusCode || IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n      const message =\n        errorBody.message || errorBody.error || this.getErrorMessageForStatus(statusCode);\n\n      // Handle conflict error with special header\n      if (\n        statusCode === IoEventsGlobals.STATUS_CODES.CONFLICT &&\n        error.response.headers?.[IoEventsGlobals.HEADERS.CONFLICTING_ID]\n      ) {\n        const conflictingId = error.response.headers[IoEventsGlobals.HEADERS.CONFLICTING_ID];\n        throw new IOEventsApiError(\n          `Provider already exists with conflicting ID: ${conflictingId}`,\n          statusCode,\n          'CONFLICT_ERROR',\n          `Conflicting provider ID: ${conflictingId}`\n        );\n      }\n\n      throw new IOEventsApiError(message, statusCode, errorBody.error_code, errorBody.details);\n    }\n\n    // Handle network errors\n    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {\n      throw new IOEventsApiError(\n        'Network error: Unable to connect to Adobe I/O Events API',\n        IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n        'NETWORK_ERROR'\n      );\n    }\n\n    // Handle timeout errors\n    if (error.code === 'ETIMEDOUT') {\n      throw new IOEventsApiError(\n        'Request timeout: Adobe I/O Events API did not respond in time',\n        IoEventsGlobals.STATUS_CODES.TIMEOUT,\n        'TIMEOUT_ERROR'\n      );\n    }\n\n    // Handle JSON parsing errors\n    if (error.message?.includes('JSON')) {\n      throw new IOEventsApiError(\n        'Invalid response format from Adobe I/O Events API',\n        IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n        'PARSE_ERROR'\n      );\n    }\n\n    // Handle validation errors\n    if (\n      error.message?.includes('is required') ||\n      error.message?.includes('Invalid response format')\n    ) {\n      throw new IOEventsApiError(\n        error.message,\n        IoEventsGlobals.STATUS_CODES.BAD_REQUEST,\n        'VALIDATION_ERROR'\n      );\n    }\n\n    // Generic error fallback\n    throw new IOEventsApiError(\n      `Failed to create provider: ${error.message || 'Unknown error occurred'}`,\n      IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n      'UNKNOWN_ERROR'\n    );\n  }\n\n  /**\n   * Extracts the status code from RestClient error message\n   *\n   * @param errorMessage - Error message like \"HTTP error! status: 404\"\n   * @returns The HTTP status code\n   */\n  private extractStatusCodeFromMessage(errorMessage: string): number {\n    const match = errorMessage.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Get specific error message based on HTTP status code\n   */\n  private getErrorMessageForStatus(status: number): string {\n    switch (status) {\n      case IoEventsGlobals.STATUS_CODES.UNAUTHORIZED:\n        return 'Unauthorized: Invalid or expired access token';\n      case IoEventsGlobals.STATUS_CODES.FORBIDDEN:\n        return 'Forbidden: Insufficient permissions or invalid scopes, or attempt to create non multi-instance provider';\n      case IoEventsGlobals.STATUS_CODES.NOT_FOUND:\n        return 'Provider metadata provided in the input model does not exist';\n      case IoEventsGlobals.STATUS_CODES.CONFLICT:\n        return 'The event provider already exists';\n      case IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR:\n        return 'Internal server error occurred while creating provider';\n      default:\n        return `HTTP ${status}: Provider creation failed`;\n    }\n  }\n}\n\nexport default Create;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IoEventsGlobals } from '../../types';\n\n/**\n * Delete Provider Service\n *\n * Handles deletion of event providers in Adobe I/O Events.\n * Implements the DELETE /events/{consumerOrgId}/{projectId}/{workspaceId}/providers/{providerId} endpoint.\n */\nexport default class Delete {\n  private readonly endpoint = IoEventsGlobals.BASE_URL;\n  private readonly restClient: RestClient;\n\n  /**\n   * Creates an instance of Delete service\n   *\n   * @param clientId - Client ID from Adobe Developer Console\n   * @param consumerId - Project Organization ID\n   * @param projectId - Project ID from Adobe Developer Console\n   * @param workspaceId - Workspace ID from Adobe Developer Console\n   * @param accessToken - IMS token for authentication\n   */\n  constructor(\n    private readonly clientId: string,\n    private readonly consumerId: string,\n    private readonly projectId: string,\n    private readonly workspaceId: string,\n    private readonly accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new Error('clientId is required and cannot be empty');\n    }\n    if (!consumerId?.trim()) {\n      throw new Error('consumerId is required and cannot be empty');\n    }\n    if (!projectId?.trim()) {\n      throw new Error('projectId is required and cannot be empty');\n    }\n    if (!workspaceId?.trim()) {\n      throw new Error('workspaceId is required and cannot be empty');\n    }\n    if (!accessToken?.trim()) {\n      throw new Error('accessToken is required and cannot be empty');\n    }\n\n    this.restClient = new RestClient();\n  }\n\n  /**\n   * Delete a provider by ID\n   *\n   * @param providerId - The ID of the provider to delete\n   * @returns Promise<void> - Resolves when provider is successfully deleted\n   * @throws IOEventsApiError - When the API request fails\n   */\n  async execute(providerId: string): Promise<void> {\n    try {\n      // Validate required parameters\n      if (!providerId?.trim()) {\n        throw new Error('providerId is required and cannot be empty');\n      }\n\n      // Build the API URL\n      const url = `${this.endpoint}/events/${this.consumerId}/${this.projectId}/${this.workspaceId}/providers/${providerId}`;\n\n      // Prepare headers\n      const headers = {\n        Authorization: `Bearer ${this.accessToken}`,\n        'x-api-key': this.clientId,\n        Accept: 'application/hal+json',\n        'Content-Type': 'application/json',\n      };\n\n      // Make the DELETE request\n      await this.restClient.delete(url, headers);\n\n      // DELETE requests with 204 response don't return content\n      // Success is indicated by no exception being thrown\n    } catch (error: any) {\n      // Handle different types of errors\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Handle and transform errors from the API call\n   * @private\n   * @param error - The caught error\n   * @throws IOEventsApiError - Transformed error with proper details\n   */\n  private handleError(error: any): never {\n    // Check if it's an HTTP error from RestClient (e.g., \"HTTP error! status: 404\")\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    // Handle HTTP errors from RestClient\n    if (error.response) {\n      const status = this.extractStatusCode(error);\n      const errorMessage = this.getErrorMessageForStatus(status);\n      throw new IOEventsApiError(errorMessage, status, 'API_ERROR');\n    }\n\n    // Handle network errors\n    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {\n      throw new IOEventsApiError(\n        'Network error: Unable to connect to Adobe I/O Events API',\n        IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n        'NETWORK_ERROR'\n      );\n    }\n\n    // Handle timeout errors\n    if (error.code === 'ETIMEDOUT' || error.message?.includes('timeout')) {\n      throw new IOEventsApiError(\n        'Request timeout: Adobe I/O Events API did not respond in time',\n        IoEventsGlobals.STATUS_CODES.TIMEOUT,\n        'TIMEOUT_ERROR'\n      );\n    }\n\n    // Handle JSON parsing errors\n    if (error.message?.includes('JSON')) {\n      throw new IOEventsApiError(\n        'Invalid response format from Adobe I/O Events API',\n        IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n        'PARSE_ERROR'\n      );\n    }\n\n    // Handle validation errors (from provider ID validation)\n    if (error.message?.includes('required') || error.message?.includes('empty')) {\n      throw new IOEventsApiError(\n        `Validation error: ${error.message}`,\n        IoEventsGlobals.STATUS_CODES.BAD_REQUEST,\n        'VALIDATION_ERROR'\n      );\n    }\n\n    // Handle generic errors\n    if (error instanceof Error) {\n      throw new IOEventsApiError(\n        `Failed to delete provider: ${error.message}`,\n        IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n        'UNKNOWN_ERROR'\n      );\n    }\n\n    // Handle unknown error types\n    throw new IOEventsApiError(\n      'Unexpected error: Unknown error occurred',\n      IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n      'UNKNOWN_ERROR'\n    );\n  }\n\n  /**\n   * Extract status code from error response\n   */\n  private extractStatusCode(error: any): number {\n    return (\n      error.response?.status || error.status || IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR\n    );\n  }\n\n  /**\n   * Extracts the status code from RestClient error message\n   *\n   * @param errorMessage - Error message like \"HTTP error! status: 404\"\n   * @returns The HTTP status code\n   */\n  private extractStatusCodeFromMessage(errorMessage: string): number {\n    const match = errorMessage.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Get appropriate error message for HTTP status code\n   */\n  private getErrorMessageForStatus(status: number): string {\n    switch (status) {\n      case IoEventsGlobals.STATUS_CODES.UNAUTHORIZED:\n        return 'Unauthorized: Invalid or expired access token';\n      case IoEventsGlobals.STATUS_CODES.FORBIDDEN:\n        return 'Forbidden: Insufficient permissions to delete provider';\n      case IoEventsGlobals.STATUS_CODES.NOT_FOUND:\n        return 'Provider not found: The specified provider ID does not exist';\n      case IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR:\n        return 'Internal server error occurred while deleting provider';\n      default:\n        return `HTTP ${status}: Provider deletion failed`;\n    }\n  }\n}\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport List from './list';\nimport Get from './get';\nimport Create from './create';\nimport Delete from './delete';\nimport { IOEventsApiError } from '../types';\nimport { Provider } from './types';\nimport { GetProviderQueryParams } from './get/types';\nimport { ListProvidersQueryParams } from './list/types';\nimport { ProviderInputModel } from './create/types';\n\n/**\n * Providers service for Adobe I/O Events\n *\n * This class provides methods to interact with event providers in Adobe I/O Events.\n * It handles authentication and provides a clean interface for provider operations.\n */\nclass ProviderManager {\n  private readonly listService: List;\n  private readonly getService: Get;\n  private readonly createService: Create;\n  private readonly deleteService: Delete;\n\n  /**\n   * Constructor for Providers service\n   *\n   * @param clientId - Client ID from Adobe Developer Console (x-api-key header)\n   * @param consumerId - Project Organization ID from Adobe Developer Console\n   * @param projectId - Project ID from Adobe Developer Console\n   * @param workspaceId - Workspace ID from Adobe Developer Console\n   * @param accessToken - IMS token for authentication (Bearer token)\n   */\n  constructor(\n    private readonly clientId: string,\n    private readonly consumerId: string,\n    private readonly projectId: string,\n    private readonly workspaceId: string,\n    private readonly accessToken: string\n  ) {\n    this.listService = new List(clientId, consumerId, projectId, workspaceId, accessToken);\n    this.getService = new Get(clientId, consumerId, projectId, workspaceId, accessToken);\n    this.createService = new Create(clientId, consumerId, projectId, workspaceId, accessToken);\n    this.deleteService = new Delete(clientId, consumerId, projectId, workspaceId, accessToken);\n  }\n\n  /**\n   * List all event providers entitled to the provided organization ID\n   *\n   * @param queryParams - Optional query parameters for filtering providers\n   * @param queryParams.providerMetadataId - Filter by provider metadata id\n   * @param queryParams.instanceId - Filter by instance id\n   * @param queryParams.providerMetadataIds - List of provider metadata ids to filter (mutually exclusive with providerMetadataId)\n   * @param queryParams.eventmetadata - Boolean to fetch provider's event metadata (default: false)\n   * @returns Promise<Provider[]> - Array of providers\n   * @throws IOEventsApiError - When API call fails with specific error details\n   *\n   * @example\n   * ```typescript\n   * // List all providers\n   * const providers = await providersService.list();\n   *\n   * // Filter by provider metadata ID\n   * const customProviders = await providersService.list({\n   *   providerMetadataId: '3rd_party_custom_events'\n   * });\n   *\n   * // Include event metadata in response\n   * const providersWithMetadata = await providersService.list({\n   *   eventmetadata: true\n   * });\n   * ```\n   */\n  async list(queryParams: ListProvidersQueryParams = {}): Promise<Provider[]> {\n    try {\n      return await this.listService.execute(queryParams);\n    } catch (error) {\n      // Re-throw IOEventsApiError as-is, or wrap other errors\n      if (error instanceof IOEventsApiError) {\n        throw error;\n      }\n      throw new IOEventsApiError(\n        `Unexpected error in providers list: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        500,\n        'UNEXPECTED_ERROR'\n      );\n    }\n  }\n\n  /**\n   * Get a specific event provider by its ID\n   *\n   * @param providerId - The ID of the provider to retrieve\n   * @param queryParams - Optional query parameters\n   * @param queryParams.eventmetadata - Boolean to fetch provider's event metadata (default: false)\n   * @returns Promise<Provider> - The provider details\n   * @throws IOEventsApiError - When API call fails with specific error details\n   *\n   * @example\n   * ```typescript\n   * // Get basic provider details\n   * const provider = await providersService.get('provider-123');\n   *\n   * // Get provider details with event metadata\n   * const providerWithMetadata = await providersService.get('provider-123', {\n   *   eventmetadata: true\n   * });\n   * ```\n   */\n  async get(providerId: string, queryParams: GetProviderQueryParams = {}): Promise<Provider> {\n    try {\n      return await this.getService.execute(providerId, queryParams);\n    } catch (error) {\n      // Re-throw IOEventsApiError as-is, or wrap other errors\n      if (error instanceof IOEventsApiError) {\n        throw error;\n      }\n      throw new IOEventsApiError(\n        `Unexpected error in providers get: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        500,\n        'UNEXPECTED_ERROR'\n      );\n    }\n  }\n\n  /**\n   * Create a new event provider\n   *\n   * @param providerData - Provider input data\n   * @param providerData.label - The label of this event provider (required)\n   * @param providerData.description - Optional description for the provider\n   * @param providerData.docs_url - Optional documentation URL for the provider\n   * @param providerData.provider_metadata - Optional provider metadata ID (defaults to '3rd_party_custom_events')\n   * @param providerData.instance_id - Optional technical instance ID\n   * @param providerData.data_residency_region - Optional data residency region (defaults to 'va6')\n   * @returns Promise<Provider> - The created provider\n   * @throws IOEventsApiError - When API call fails with specific error details\n   *\n   * @example\n   * ```typescript\n   * // Create a basic provider\n   * const provider = await providersService.create({\n   *   label: 'My Event Provider'\n   * });\n   *\n   * // Create a provider with custom details\n   * const customProvider = await providersService.create({\n   *   label: 'My Custom Provider',\n   *   description: 'Provider for custom business events',\n   *   provider_metadata: '3rd_party_custom_events',\n   *   instance_id: 'production-instance'\n   * });\n   * ```\n   */\n  async create(providerData: ProviderInputModel): Promise<Provider> {\n    try {\n      return await this.createService.execute(providerData);\n    } catch (error) {\n      // Re-throw IOEventsApiError as-is, or wrap other errors\n      if (error instanceof IOEventsApiError) {\n        throw error;\n      }\n      throw new IOEventsApiError(\n        `Unexpected error in providers create: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        500,\n        'UNEXPECTED_ERROR'\n      );\n    }\n  }\n\n  /**\n   * Delete an event provider by ID\n   *\n   * @param providerId - The ID of the provider to delete\n   * @returns Promise<void> - Resolves when provider is successfully deleted\n   * @throws IOEventsApiError - When API call fails with specific error details\n   *\n   * @example\n   * ```typescript\n   * // Delete a provider by ID\n   * await providersService.delete('provider-123');\n   * console.log('Provider deleted successfully');\n   * ```\n   */\n  async delete(providerId: string): Promise<void> {\n    try {\n      return await this.deleteService.execute(providerId);\n    } catch (error) {\n      // Re-throw IOEventsApiError as-is, or wrap other errors\n      if (error instanceof IOEventsApiError) {\n        throw error;\n      }\n      throw new IOEventsApiError(\n        `Unexpected error in providers delete: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        500,\n        'UNEXPECTED_ERROR'\n      );\n    }\n  }\n}\n\nexport default ProviderManager;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IoEventsGlobals } from '../../types';\nimport { EventMetadata } from '../types';\nimport { EventMetadataListResponse } from './types';\n\n/**\n * Service class for listing all event metadata for a provider\n *\n * Handles: GET /events/providers/{providerId}/eventmetadata\n */\nexport default class List {\n  private readonly restClient: RestClient;\n\n  /**\n   * Creates an instance of List service\n   *\n   * @param clientId - The Adobe I/O client ID (API key)\n   * @param consumerId - The consumer organization ID\n   * @param projectId - The project ID\n   * @param workspaceId - The workspace ID\n   * @param accessToken - The access token for authentication\n   */\n  constructor(\n    private readonly clientId: string,\n    private readonly consumerId: string,\n    private readonly projectId: string,\n    private readonly workspaceId: string,\n    private readonly accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new Error('clientId is required and cannot be empty');\n    }\n    if (!consumerId?.trim()) {\n      throw new Error('consumerId is required and cannot be empty');\n    }\n    if (!projectId?.trim()) {\n      throw new Error('projectId is required and cannot be empty');\n    }\n    if (!workspaceId?.trim()) {\n      throw new Error('workspaceId is required and cannot be empty');\n    }\n    if (!accessToken?.trim()) {\n      throw new Error('accessToken is required and cannot be empty');\n    }\n\n    this.restClient = new RestClient();\n  }\n\n  /**\n   * Retrieves all event metadata for a provider with automatic pagination\n   *\n   * This method automatically follows pagination links to fetch all event metadata\n   * across multiple pages, returning a complete array of all event metadata.\n   *\n   * @param providerId - The ID of the provider to fetch event metadata for\n   * @returns Promise<EventMetadata[]> - Array of all event metadata across all pages\n   * @throws IOEventsApiError - When the API request fails\n   */\n  async execute(providerId: string): Promise<EventMetadata[]> {\n    if (!providerId?.trim()) {\n      throw new IOEventsApiError(\n        'providerId is required and cannot be empty',\n        400,\n        'VALIDATION_ERROR'\n      );\n    }\n\n    try {\n      const url = `${IoEventsGlobals.BASE_URL}/events/${this.consumerId}/${this.projectId}/${this.workspaceId}/providers/${providerId}/eventmetadata`;\n      return await this.fetchAllPages(url);\n    } catch (error: any) {\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Recursively fetches all pages of event metadata using pagination links\n   *\n   * @param url - The URL to fetch (either initial URL or next page URL)\n   * @param accumulatedResults - Array to accumulate results across pages\n   * @returns Promise<EventMetadata[]> - Complete array of all event metadata\n   * @private\n   */\n  private async fetchAllPages(\n    url: string,\n    accumulatedResults: EventMetadata[] = []\n  ): Promise<EventMetadata[]> {\n    const response = await this.restClient.get(url, {\n      Authorization: `Bearer ${this.accessToken}`,\n      'x-api-key': this.clientId,\n      Accept: 'application/hal+json',\n    });\n\n    // Validate response format\n    if (response === null || response === undefined) {\n      throw new IOEventsApiError(\n        'Invalid response format: Expected object',\n        IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n        'PARSE_ERROR'\n      );\n    }\n\n    if (typeof response !== 'object') {\n      throw new IOEventsApiError(\n        'Invalid response format: Expected object',\n        IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n        'PARSE_ERROR'\n      );\n    }\n\n    const data = response as EventMetadataListResponse;\n\n    // Validate _embedded structure\n    if (!data._embedded || !Array.isArray(data._embedded.eventmetadata)) {\n      throw new IOEventsApiError(\n        'Invalid response format: Expected eventmetadata array',\n        IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n        'PARSE_ERROR'\n      );\n    }\n\n    const currentPageResults = data._embedded.eventmetadata;\n\n    // Accumulate results from current page\n    const allResults = [...accumulatedResults, ...currentPageResults];\n\n    // Check if there's a next page\n    const nextPageUrl = data._links?.next?.href;\n\n    if (nextPageUrl) {\n      // Recursively fetch the next page\n      return await this.fetchAllPages(nextPageUrl, allResults);\n    }\n\n    // No more pages, return all accumulated results\n    return allResults;\n  }\n\n  /**\n   * Handles errors from the API request\n   *\n   * @param error - The error object from the API request\n   * @throws IOEventsApiError - Always throws with appropriate error details\n   */\n  private handleError(error: any): never {\n    // Check if it's an HTTP error from RestClient (e.g., \"HTTP error! status: 404\")\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    // Check if it's a structured API error response\n    if (error.response) {\n      const statusCode = this.extractStatusCode(error);\n      const errorMessage =\n        error.response.body?.message || this.getErrorMessageForStatus(statusCode);\n\n      throw new IOEventsApiError(\n        errorMessage,\n        statusCode,\n        error.response.body,\n        error.response.headers\n      );\n    }\n\n    // Handle other types of errors (network, timeout, parsing, etc.)\n    let errorMessage: string;\n    let statusCode: number;\n\n    if (error instanceof Error) {\n      if (error.message.includes('timeout') || error.message.includes('ETIMEDOUT')) {\n        errorMessage = 'Request timeout while listing event metadata';\n        statusCode = IoEventsGlobals.STATUS_CODES.REQUEST_TIMEOUT;\n      } else if (error.message.includes('JSON') || error.message.includes('parse')) {\n        errorMessage = 'Invalid response format from Adobe I/O Events API';\n        statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n        throw new IOEventsApiError(errorMessage, statusCode, 'PARSE_ERROR');\n      } else {\n        errorMessage = `Network error: ${error.message}`;\n        statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n      }\n    } else {\n      errorMessage = `API Error: HTTP ${IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR}`;\n      statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n    }\n\n    throw new IOEventsApiError(errorMessage, statusCode);\n  }\n\n  /**\n   * Extracts the status code from the error response\n   *\n   * @param error - The error object\n   * @returns The HTTP status code\n   */\n  private extractStatusCode(error: any): number {\n    return error.response?.status || IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Extracts the status code from RestClient error message\n   *\n   * @param errorMessage - Error message like \"HTTP error! status: 404\"\n   * @returns The HTTP status code\n   */\n  private extractStatusCodeFromMessage(errorMessage: string): number {\n    const match = errorMessage.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Gets a human-readable error message for a given HTTP status code\n   *\n   * @param statusCode - The HTTP status code\n   * @returns A descriptive error message\n   */\n  private getErrorMessageForStatus(statusCode: number): string {\n    switch (statusCode) {\n      case IoEventsGlobals.STATUS_CODES.BAD_REQUEST:\n        return 'Invalid request parameters for listing event metadata';\n      case IoEventsGlobals.STATUS_CODES.UNAUTHORIZED:\n        return 'Authentication failed. Please check your access token';\n      case IoEventsGlobals.STATUS_CODES.FORBIDDEN:\n        return 'Access forbidden. You do not have permission to access event metadata';\n      case IoEventsGlobals.STATUS_CODES.NOT_FOUND:\n        return 'Provider not found or no event metadata available';\n      case IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR:\n        return 'Internal server error occurred while listing event metadata';\n      default:\n        return `Unexpected error occurred: HTTP ${statusCode}`;\n    }\n  }\n}\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IoEventsGlobals } from '../../types';\nimport { EventMetadata } from '../types';\n\n/**\n * Service class for getting specific event metadata by provider ID and event code\n */\nexport default class Get {\n  private readonly restClient: RestClient;\n\n  /**\n   * Creates an instance of Get service\n   *\n   * @param clientId - The Adobe I/O client ID (API key)\n   * @param consumerId - The consumer organization ID\n   * @param projectId - The project ID\n   * @param workspaceId - The workspace ID\n   * @param accessToken - The access token for authentication\n   */\n  constructor(\n    private readonly clientId: string,\n    private readonly consumerId: string,\n    private readonly projectId: string,\n    private readonly workspaceId: string,\n    private readonly accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new Error('clientId is required and cannot be empty');\n    }\n    if (!consumerId?.trim()) {\n      throw new Error('consumerId is required and cannot be empty');\n    }\n    if (!projectId?.trim()) {\n      throw new Error('projectId is required and cannot be empty');\n    }\n    if (!workspaceId?.trim()) {\n      throw new Error('workspaceId is required and cannot be empty');\n    }\n    if (!accessToken?.trim()) {\n      throw new Error('accessToken is required and cannot be empty');\n    }\n\n    this.restClient = new RestClient();\n  }\n\n  /**\n   * Retrieves specific event metadata by provider ID and event code\n   *\n   * @param providerId - The ID of the provider\n   * @param eventCode - The event code to get metadata for\n   * @returns Promise<EventMetadata> - The event metadata\n   * @throws IOEventsApiError - When the API request fails\n   */\n  async execute(providerId: string, eventCode: string): Promise<EventMetadata> {\n    if (!providerId?.trim()) {\n      throw new IOEventsApiError(\n        'providerId is required and cannot be empty',\n        400,\n        'VALIDATION_ERROR'\n      );\n    }\n    if (!eventCode?.trim()) {\n      throw new IOEventsApiError(\n        'eventCode is required and cannot be empty',\n        400,\n        'VALIDATION_ERROR'\n      );\n    }\n\n    try {\n      const url = `${IoEventsGlobals.BASE_URL}/events/${this.consumerId}/${this.projectId}/${this.workspaceId}/providers/${providerId}/eventmetadata/${encodeURIComponent(eventCode)}`;\n\n      const response = await this.restClient.get(url, {\n        Authorization: `Bearer ${this.accessToken}`,\n        'x-api-key': this.clientId,\n        Accept: 'application/hal+json',\n      });\n\n      // Validate response format\n      if (response === null || response === undefined) {\n        throw new IOEventsApiError(\n          'Invalid response format: Expected object',\n          IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n          'PARSE_ERROR'\n        );\n      }\n\n      if (typeof response !== 'object') {\n        throw new IOEventsApiError(\n          'Invalid response format: Expected object',\n          IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR,\n          'PARSE_ERROR'\n        );\n      }\n\n      return response as EventMetadata;\n    } catch (error: any) {\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Handles errors from the API request\n   *\n   * @param error - The error object from the API request\n   * @throws IOEventsApiError - Always throws with appropriate error details\n   */\n  private handleError(error: any): never {\n    // Check if it's an HTTP error from RestClient (e.g., \"HTTP error! status: 404\")\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    // Check if it's a structured API error response\n    if (error.response) {\n      const statusCode = this.extractStatusCode(error);\n      const errorMessage =\n        error.response.body?.message || this.getErrorMessageForStatus(statusCode);\n\n      throw new IOEventsApiError(\n        errorMessage,\n        statusCode,\n        error.response.body?.error_code,\n        error.response.body?.details\n      );\n    }\n\n    // Handle other types of errors (network, timeout, parsing, etc.)\n    let errorMessage: string;\n    let statusCode: number;\n\n    if (error instanceof Error) {\n      if (error.message.includes('timeout') || error.message.includes('ETIMEDOUT')) {\n        errorMessage = 'Request timeout while getting event metadata';\n        statusCode = IoEventsGlobals.STATUS_CODES.REQUEST_TIMEOUT;\n      } else if (error.message.includes('JSON') || error.message.includes('parse')) {\n        errorMessage = 'Invalid response format from Adobe I/O Events API';\n        statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n        throw new IOEventsApiError(errorMessage, statusCode, 'PARSE_ERROR');\n      } else {\n        errorMessage = `Network error: ${error.message}`;\n        statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n      }\n    } else {\n      errorMessage = `API Error: HTTP ${IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR}`;\n      statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n    }\n\n    throw new IOEventsApiError(errorMessage, statusCode);\n  }\n\n  /**\n   * Extracts the status code from the error response\n   *\n   * @param error - The error object\n   * @returns The HTTP status code\n   */\n  private extractStatusCode(error: any): number {\n    return error.response?.status || IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Extracts the status code from RestClient error message\n   *\n   * @param errorMessage - Error message like \"HTTP error! status: 404\"\n   * @returns The HTTP status code\n   */\n  private extractStatusCodeFromMessage(errorMessage: string): number {\n    const match = errorMessage.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Gets a human-readable error message for a given HTTP status code\n   *\n   * @param statusCode - The HTTP status code\n   * @returns A descriptive error message\n   */\n  private getErrorMessageForStatus(statusCode: number): string {\n    switch (statusCode) {\n      case IoEventsGlobals.STATUS_CODES.BAD_REQUEST:\n        return 'Invalid request parameters for getting event metadata';\n      case IoEventsGlobals.STATUS_CODES.UNAUTHORIZED:\n        return 'Authentication failed. Please check your access token';\n      case IoEventsGlobals.STATUS_CODES.FORBIDDEN:\n        return 'Access forbidden. You do not have permission to access this event metadata';\n      case IoEventsGlobals.STATUS_CODES.NOT_FOUND:\n        return 'Event metadata not found for the specified provider and event code';\n      case IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR:\n        return 'Internal server error occurred while getting event metadata';\n      default:\n        return `Unexpected error occurred: HTTP ${statusCode}`;\n    }\n  }\n}\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IoEventsGlobals } from '../../types';\nimport { EventMetadata } from '../types';\nimport { EventMetadataInputModel } from './types';\n\n/**\n * Create event metadata for Adobe I/O Events\n *\n * This class handles the creation of event metadata for a specific provider.\n * It validates the input data and makes the appropriate API call to create\n * the event metadata in Adobe I/O Events.\n */\nclass Create {\n  private readonly endpoint: string = IoEventsGlobals.BASE_URL;\n  private readonly restClient: RestClient;\n\n  /**\n   * Constructor for Create event metadata service\n   *\n   * @param clientId - Client ID from Adobe Developer Console (x-api-key header)\n   * @param consumerId - Project Organization ID from Adobe Developer Console\n   * @param projectId - Project ID from Adobe Developer Console\n   * @param workspaceId - Workspace ID from Adobe Developer Console\n   * @param accessToken - IMS token for authentication (Bearer token)\n   */\n  constructor(\n    private readonly clientId: string,\n    private readonly consumerId: string,\n    private readonly projectId: string,\n    private readonly workspaceId: string,\n    private readonly accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new Error('clientId is required and cannot be empty');\n    }\n    if (!consumerId?.trim()) {\n      throw new Error('consumerId is required and cannot be empty');\n    }\n    if (!projectId?.trim()) {\n      throw new Error('projectId is required and cannot be empty');\n    }\n    if (!workspaceId?.trim()) {\n      throw new Error('workspaceId is required and cannot be empty');\n    }\n    if (!accessToken?.trim()) {\n      throw new Error('accessToken is required and cannot be empty');\n    }\n\n    this.restClient = new RestClient();\n  }\n\n  /**\n   * Execute the create event metadata API call\n   *\n   * @param providerId - The ID of the provider to create event metadata for\n   * @param eventMetadataData - The event metadata input model\n   * @returns Promise<EventMetadata> - The created event metadata\n   * @throws IOEventsApiError - When API call fails with specific error details\n   */\n  async execute(\n    providerId: string,\n    eventMetadataData: EventMetadataInputModel\n  ): Promise<EventMetadata> {\n    try {\n      // Validate required parameters\n      if (!providerId?.trim()) {\n        throw new IOEventsApiError(\n          'providerId is required and cannot be empty',\n          400,\n          'VALIDATION_ERROR'\n        );\n      }\n\n      if (!eventMetadataData) {\n        throw new IOEventsApiError('eventMetadataData is required', 400, 'VALIDATION_ERROR');\n      }\n\n      // Validate required fields in eventMetadataData\n      this.validateEventMetadataInput(eventMetadataData);\n\n      // Convert the input data for API submission\n      const apiPayload = this.convertToApiPayload(eventMetadataData);\n\n      // Build the API URL\n      const url = `${this.endpoint}/events/${this.consumerId}/${this.projectId}/${this.workspaceId}/providers/${providerId}/eventmetadata`;\n\n      // Prepare headers as required by the API\n      const headers = {\n        Authorization: `Bearer ${this.accessToken}`,\n        'x-api-key': this.clientId,\n        Accept: 'application/hal+json',\n        'Content-Type': 'application/json',\n      };\n\n      // Make the POST request\n      const response: EventMetadata = await this.restClient.post(url, headers, apiPayload);\n\n      // Validate response format\n      if (response === null || response === undefined) {\n        throw new IOEventsApiError(\n          'Invalid response format: Expected object',\n          IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR\n        );\n      }\n\n      if (typeof response !== 'object') {\n        throw new IOEventsApiError(\n          'Invalid response format: Expected object',\n          IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR\n        );\n      }\n\n      return response;\n    } catch (error: any) {\n      // Handle different types of errors\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Validates the event metadata input data\n   *\n   * @param eventMetadataData - The event metadata input to validate\n   * @throws Error - When validation fails\n   * @private\n   */\n  private validateEventMetadataInput(eventMetadataData: EventMetadataInputModel): void {\n    const { description, label, event_code, sample_event_template } = eventMetadataData;\n\n    // Validate required fields\n    if (!description?.trim()) {\n      throw new IOEventsApiError(\n        'description is required and cannot be empty',\n        400,\n        'VALIDATION_ERROR'\n      );\n    }\n\n    if (!label?.trim()) {\n      throw new IOEventsApiError('label is required and cannot be empty', 400, 'VALIDATION_ERROR');\n    }\n\n    if (!event_code?.trim()) {\n      throw new IOEventsApiError(\n        'event_code is required and cannot be empty',\n        400,\n        'VALIDATION_ERROR'\n      );\n    }\n\n    // Validate field lengths\n    if (description.length > 255) {\n      throw new Error('description cannot exceed 255 characters');\n    }\n\n    if (label.length > 255) {\n      throw new Error('label cannot exceed 255 characters');\n    }\n\n    if (event_code.length > 255) {\n      throw new Error('event_code cannot exceed 255 characters');\n    }\n\n    // Validate patterns (basic validation - API will do full validation)\n    const descriptionPattern = /^[\\w\\s\\-_.(),:''`?#!]+$/;\n    if (!descriptionPattern.test(description)) {\n      throw new Error('description contains invalid characters');\n    }\n\n    const labelPattern = /^[\\w\\s\\-_.(),:''`?#!]+$/;\n    if (!labelPattern.test(label)) {\n      throw new Error('label contains invalid characters');\n    }\n\n    const eventCodePattern = /^[\\w\\-_.]+$/;\n    if (!eventCodePattern.test(event_code)) {\n      throw new Error('event_code contains invalid characters');\n    }\n\n    // Validate sample_event_template if provided\n    if (sample_event_template !== undefined) {\n      if (typeof sample_event_template !== 'object' || sample_event_template === null) {\n        throw new Error('sample_event_template must be a valid JSON object');\n      }\n\n      try {\n        // Check if the JSON string representation would exceed the base64 limit\n        // Base64 encoding increases size by ~33%, so we check the JSON string length\n        const jsonString = JSON.stringify(sample_event_template);\n        const base64Length = Buffer.from(jsonString).toString('base64').length;\n\n        if (base64Length > 87382) {\n          throw new Error('sample_event_template JSON object is too large when base64 encoded');\n        }\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes('sample_event_template JSON object is too large')\n        ) {\n          throw error; // Re-throw our validation error\n        }\n        throw new Error('sample_event_template must be a valid JSON object');\n      }\n    }\n  }\n\n  /**\n   * Converts the input data to the format expected by the API\n   *\n   * @param eventMetadataData - The event metadata input data\n   * @returns The converted payload for the API\n   * @private\n   */\n  private convertToApiPayload(eventMetadataData: EventMetadataInputModel): any {\n    const { sample_event_template, ...rest } = eventMetadataData;\n\n    const payload: any = { ...rest };\n\n    // Convert sample_event_template from JSON object to base64 string if provided\n    if (sample_event_template !== undefined) {\n      payload.sample_event_template = Buffer.from(JSON.stringify(sample_event_template)).toString(\n        'base64'\n      );\n    }\n\n    return payload;\n  }\n\n  /**\n   * Handles errors from the API request\n   *\n   * @param error - The error object from the API request\n   * @throws IOEventsApiError - Always throws with appropriate error details\n   * @private\n   */\n  private handleError(error: any): never {\n    // If it's already an IOEventsApiError, re-throw it\n    if (error instanceof IOEventsApiError) {\n      throw error;\n    }\n\n    // Check if it's an HTTP error from RestClient (e.g., \"HTTP error! status: 404\")\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    // Check if it's a structured API error response\n    if (error.response) {\n      const statusCode = this.extractStatusCode(error);\n      const errorMessage =\n        error.response.body?.message || this.getErrorMessageForStatus(statusCode);\n\n      throw new IOEventsApiError(\n        errorMessage,\n        statusCode,\n        error.response.body?.error_code,\n        error.response.body?.details\n      );\n    }\n\n    // Handle other types of errors (network, timeout, parsing, etc.)\n    let errorMessage: string;\n    let statusCode: number;\n\n    if (error instanceof Error) {\n      if (error.message.includes('timeout') || error.message.includes('ETIMEDOUT')) {\n        errorMessage = 'Request timeout while creating event metadata';\n        statusCode = IoEventsGlobals.STATUS_CODES.REQUEST_TIMEOUT;\n      } else if (\n        error.message.includes('is required') ||\n        error.message.includes('cannot be empty') ||\n        error.message.includes('cannot exceed') ||\n        error.message.includes('contains invalid characters') ||\n        error.message.includes('must be a valid') ||\n        error.message.includes('too large when base64 encoded')\n      ) {\n        // Validation errors should be thrown as-is with 400 status\n        throw new IOEventsApiError(\n          error.message,\n          IoEventsGlobals.STATUS_CODES.BAD_REQUEST,\n          'VALIDATION_ERROR'\n        );\n      } else if (error.message.includes('JSON') || error.message.includes('parse')) {\n        errorMessage = 'Invalid response format from Adobe I/O Events API';\n        statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n      } else {\n        errorMessage = `Network error: ${error.message}`;\n        statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n      }\n    } else {\n      errorMessage = `API Error: HTTP ${IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR}`;\n      statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n    }\n\n    throw new IOEventsApiError(errorMessage, statusCode);\n  }\n\n  /**\n   * Extracts the status code from the error response\n   *\n   * @param error - The error object\n   * @returns The HTTP status code\n   * @private\n   */\n  private extractStatusCode(error: any): number {\n    return error.response?.status || IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Extracts the status code from RestClient error message\n   *\n   * @param errorMessage - Error message like \"HTTP error! status: 404\"\n   * @returns The HTTP status code\n   * @private\n   */\n  private extractStatusCodeFromMessage(errorMessage: string): number {\n    const match = errorMessage.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Gets a human-readable error message based on HTTP status code\n   *\n   * @param statusCode - HTTP status code\n   * @returns string - User-friendly error message\n   * @private\n   */\n  private getErrorMessageForStatus(statusCode: number): string {\n    switch (statusCode) {\n      case IoEventsGlobals.STATUS_CODES.BAD_REQUEST:\n        return 'Invalid request parameters for creating event metadata';\n      case IoEventsGlobals.STATUS_CODES.UNAUTHORIZED:\n        return 'Authentication failed. Please check your access token';\n      case IoEventsGlobals.STATUS_CODES.FORBIDDEN:\n        return 'Access forbidden. You do not have permission to create event metadata';\n      case IoEventsGlobals.STATUS_CODES.NOT_FOUND:\n        return 'Provider not found. The specified provider ID does not exist';\n      case IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR:\n        return 'Internal server error occurred while creating event metadata';\n      default:\n        return `Unexpected error occurred: HTTP ${statusCode}`;\n    }\n  }\n}\n\nexport default Create;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IoEventsGlobals } from '../../types';\n\n/**\n * Delete all event metadata for a provider in Adobe I/O Events\n *\n * This class handles the deletion of all event metadata associated with a specific provider.\n * The operation returns 204 No Content on successful deletion.\n */\nclass Delete {\n  private readonly endpoint: string = IoEventsGlobals.BASE_URL;\n  private readonly restClient: RestClient;\n\n  /**\n   * Constructor for Delete event metadata service\n   *\n   * @param clientId - Client ID from Adobe Developer Console (x-api-key header)\n   * @param consumerId - Project Organization ID from Adobe Developer Console\n   * @param projectId - Project ID from Adobe Developer Console\n   * @param workspaceId - Workspace ID from Adobe Developer Console\n   * @param accessToken - IMS token for authentication (Bearer token)\n   */\n  constructor(\n    private readonly clientId: string,\n    private readonly consumerId: string,\n    private readonly projectId: string,\n    private readonly workspaceId: string,\n    private readonly accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new Error('clientId is required and cannot be empty');\n    }\n    if (!consumerId?.trim()) {\n      throw new Error('consumerId is required and cannot be empty');\n    }\n    if (!projectId?.trim()) {\n      throw new Error('projectId is required and cannot be empty');\n    }\n    if (!workspaceId?.trim()) {\n      throw new Error('workspaceId is required and cannot be empty');\n    }\n    if (!accessToken?.trim()) {\n      throw new Error('accessToken is required and cannot be empty');\n    }\n\n    this.restClient = new RestClient();\n  }\n\n  /**\n   * Execute the delete event metadata API call\n   *\n   * @param providerId - The ID of the provider to delete event metadata for\n   * @param eventCode - Optional event code to delete specific event metadata. If not provided, deletes all event metadata for the provider\n   * @returns Promise<void> - No content returned on successful deletion (204)\n   * @throws IOEventsApiError - When API call fails with specific error details\n   */\n  async execute(providerId: string, eventCode?: string): Promise<void> {\n    try {\n      // Validate required parameters\n      if (!providerId?.trim()) {\n        throw new IOEventsApiError(\n          'providerId is required and cannot be empty',\n          400,\n          'VALIDATION_ERROR'\n        );\n      }\n\n      // Validate eventCode if provided\n      if (eventCode !== undefined && !eventCode?.trim()) {\n        throw new IOEventsApiError(\n          'eventCode cannot be empty when provided',\n          400,\n          'VALIDATION_ERROR'\n        );\n      }\n\n      // Build the API URL - append eventCode if provided for specific deletion\n      let url = `${this.endpoint}/events/${this.consumerId}/${this.projectId}/${this.workspaceId}/providers/${providerId}/eventmetadata`;\n      if (eventCode?.trim()) {\n        url += `/${encodeURIComponent(eventCode.trim())}`;\n      }\n\n      // Prepare headers as required by the API\n      const headers = {\n        Authorization: `Bearer ${this.accessToken}`,\n        'x-api-key': this.clientId,\n        Accept: 'application/hal+json',\n      };\n\n      // Make the DELETE request - RestClient should handle 204 No Content properly\n      await this.restClient.delete(url, headers);\n\n      // No return value for 204 No Content\n    } catch (error: any) {\n      // Handle different types of errors\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Handles errors from the API request\n   *\n   * @param error - The error object from the API request\n   * @throws IOEventsApiError - Always throws with appropriate error details\n   * @private\n   */\n  private handleError(error: any): never {\n    // If it's already an IOEventsApiError, re-throw it\n    if (error instanceof IOEventsApiError) {\n      throw error;\n    }\n\n    // Check if it's an HTTP error from RestClient (e.g., \"HTTP error! status: 404\")\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    // Check if it's a structured API error response\n    if (error.response) {\n      const statusCode = this.extractStatusCode(error);\n      const errorMessage =\n        error.response.body?.message || this.getErrorMessageForStatus(statusCode);\n\n      throw new IOEventsApiError(\n        errorMessage,\n        statusCode,\n        error.response.body?.error_code,\n        error.response.body?.details\n      );\n    }\n\n    // Handle other types of errors (network, timeout, parsing, etc.)\n    let errorMessage: string;\n    let statusCode: number;\n\n    if (error instanceof Error) {\n      if (error.message.includes('timeout') || error.message.includes('ETIMEDOUT')) {\n        errorMessage = 'Request timeout while deleting event metadata';\n        statusCode = IoEventsGlobals.STATUS_CODES.REQUEST_TIMEOUT;\n      } else if (\n        error.message.includes('is required') ||\n        error.message.includes('cannot be empty')\n      ) {\n        // Validation errors should be thrown as-is with 400 status\n        throw new IOEventsApiError(\n          error.message,\n          IoEventsGlobals.STATUS_CODES.BAD_REQUEST,\n          'VALIDATION_ERROR'\n        );\n      } else if (error.message.includes('JSON') || error.message.includes('parse')) {\n        errorMessage = 'Invalid response format from Adobe I/O Events API';\n        statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n      } else {\n        errorMessage = `Network error: ${error.message}`;\n        statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n      }\n    } else {\n      errorMessage = `API Error: HTTP ${IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR}`;\n      statusCode = IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n    }\n\n    throw new IOEventsApiError(errorMessage, statusCode);\n  }\n\n  /**\n   * Extracts the status code from the error response\n   *\n   * @param error - The error object\n   * @returns The HTTP status code\n   * @private\n   */\n  private extractStatusCode(error: any): number {\n    return error.response?.status || IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Extracts the status code from RestClient error message\n   *\n   * @param errorMessage - Error message like \"HTTP error! status: 404\"\n   * @returns The HTTP status code\n   * @private\n   */\n  private extractStatusCodeFromMessage(errorMessage: string): number {\n    const match = errorMessage.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Gets a human-readable error message based on HTTP status code\n   *\n   * @param statusCode - HTTP status code\n   * @returns string - User-friendly error message\n   * @private\n   */\n  private getErrorMessageForStatus(statusCode: number): string {\n    switch (statusCode) {\n      case IoEventsGlobals.STATUS_CODES.UNAUTHORIZED:\n        return 'Authentication failed. Please check your access token';\n      case IoEventsGlobals.STATUS_CODES.FORBIDDEN:\n        return 'Access forbidden. You do not have permission to delete event metadata';\n      case IoEventsGlobals.STATUS_CODES.NOT_FOUND:\n        return 'Provider or event metadata not found. The specified provider ID or event code does not exist';\n      case IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR:\n        return 'Internal server error occurred while deleting event metadata';\n      default:\n        return `Unexpected error occurred: HTTP ${statusCode}`;\n    }\n  }\n}\n\nexport default Delete;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport List from './list';\nimport Get from './get';\nimport Create from './create';\nimport Delete from './delete';\nimport { IOEventsApiError } from '../types';\nimport { EventMetadata } from './types';\nimport { EventMetadataInputModel } from './create/types';\n\n/**\n * Main class for managing event metadata operations\n *\n * Provides methods to interact with Adobe I/O Events API for event metadata management.\n * Supports listing, getting, creating, and deleting event metadata for providers.\n */\nclass EventMetadataManager {\n  private readonly listService: List;\n  private readonly getService: Get;\n  private readonly createService: Create;\n  private readonly deleteService: Delete;\n\n  /**\n   * Creates an instance of EventMetadataManager\n   *\n   * @param clientId - Adobe I/O Client ID for API authentication\n   * @param consumerId - Consumer organization ID\n   * @param projectId - Project ID within the consumer organization\n   * @param workspaceId - Workspace ID within the project\n   * @param accessToken - Access token for API authentication\n   */\n  constructor(\n    private readonly clientId: string,\n    private readonly consumerId: string,\n    private readonly projectId: string,\n    private readonly workspaceId: string,\n    private readonly accessToken: string\n  ) {\n    this.listService = new List(clientId, consumerId, projectId, workspaceId, accessToken);\n    this.getService = new Get(clientId, consumerId, projectId, workspaceId, accessToken);\n    this.createService = new Create(clientId, consumerId, projectId, workspaceId, accessToken);\n    this.deleteService = new Delete(clientId, consumerId, projectId, workspaceId, accessToken);\n  }\n\n  /**\n   * Lists all event metadata for a provider\n   *\n   * @param providerId - The ID of the provider to fetch event metadata for\n   * @returns Promise<EventMetadata[]> - Array of event metadata\n   * @throws IOEventsApiError - When the API request fails\n   *\n   * @example\n   * // List all event metadata for a provider\n   * const allMetadata = await eventMetadata.list('provider-123');\n   */\n  async list(providerId: string): Promise<EventMetadata[]> {\n    try {\n      return await this.listService.execute(providerId);\n    } catch (error) {\n      if (error instanceof IOEventsApiError) {\n        throw error;\n      }\n      throw new IOEventsApiError(\n        `Unexpected error in event metadata list: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        500,\n        'UNEXPECTED_ERROR'\n      );\n    }\n  }\n\n  /**\n   * Gets specific event metadata by provider ID and event code\n   *\n   * @param providerId - The ID of the provider\n   * @param eventCode - The event code to get metadata for\n   * @returns Promise<EventMetadata> - The event metadata\n   * @throws IOEventsApiError - When the API request fails\n   *\n   * @example\n   * // Get specific event metadata by event code\n   * const specificMetadata = await eventMetadata.get('provider-123', 'user.created');\n   */\n  async get(providerId: string, eventCode: string): Promise<EventMetadata> {\n    try {\n      return await this.getService.execute(providerId, eventCode);\n    } catch (error) {\n      if (error instanceof IOEventsApiError) {\n        throw error;\n      }\n      throw new IOEventsApiError(\n        `Unexpected error in event metadata get: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        500,\n        'UNEXPECTED_ERROR'\n      );\n    }\n  }\n\n  /**\n   * Creates new event metadata for a provider\n   *\n   * @param providerId - The ID of the provider to create event metadata for\n   * @param eventMetadataData - The event metadata input data\n   * @returns Promise<EventMetadata> - The created event metadata\n   * @throws IOEventsApiError - When the API request fails\n   *\n   * @example\n   * // Create new event metadata\n   * const newMetadata = await eventMetadata.create('provider-123', {\n   *   event_code: 'com.example.user.created',\n   *   label: 'User Created',\n   *   description: 'Triggered when a new user is created',\n   *   sample_event_template: { name: 'John Doe', email: 'john@example.com' } // JSON object\n   * });\n   */\n  async create(\n    providerId: string,\n    eventMetadataData: EventMetadataInputModel\n  ): Promise<EventMetadata> {\n    try {\n      return await this.createService.execute(providerId, eventMetadataData);\n    } catch (error) {\n      if (error instanceof IOEventsApiError) {\n        throw error;\n      }\n      throw new IOEventsApiError(\n        `Unexpected error in event metadata create: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        500,\n        'UNEXPECTED_ERROR'\n      );\n    }\n  }\n\n  /**\n   * Deletes event metadata for a provider\n   *\n   * @param providerId - The ID of the provider to delete event metadata for\n   * @param eventCode - Optional event code to delete specific event metadata. If not provided, deletes all event metadata for the provider\n   * @returns Promise<void> - No content returned on successful deletion\n   * @throws IOEventsApiError - When the API request fails\n   *\n   * @example\n   * // Delete all event metadata for a provider\n   * await eventMetadata.delete('provider-123');\n   *\n   * @example\n   * // Delete specific event metadata by event code\n   * await eventMetadata.delete('provider-123', 'com.example.user.created');\n   */\n  async delete(providerId: string, eventCode?: string): Promise<void> {\n    try {\n      return await this.deleteService.execute(providerId, eventCode);\n    } catch (error) {\n      if (error instanceof IOEventsApiError) {\n        throw error;\n      }\n      throw new IOEventsApiError(\n        `Unexpected error in event metadata delete: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        500,\n        'UNEXPECTED_ERROR'\n      );\n    }\n  }\n}\n\nexport default EventMetadataManager;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IoEventsGlobals } from '../../types';\nimport type { Registration } from '../types';\nimport type { RegistrationCreateModel } from './types';\n\n/**\n * Service for creating registrations\n */\nexport class Create {\n  private restClient: RestClient;\n  private endpoint: string;\n  private consumerId: string;\n  private projectId: string;\n  private workspaceId: string;\n  private accessToken: string;\n\n  /**\n   * Initialize the Create service\n   */\n  constructor(\n    clientId: string,\n    consumerId: string,\n    projectId: string,\n    workspaceId: string,\n    accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new IOEventsApiError('clientId is required and cannot be empty', 400);\n    }\n    if (!consumerId?.trim()) {\n      throw new IOEventsApiError('consumerId is required and cannot be empty', 400);\n    }\n    if (!projectId?.trim()) {\n      throw new IOEventsApiError('projectId is required and cannot be empty', 400);\n    }\n    if (!workspaceId?.trim()) {\n      throw new IOEventsApiError('workspaceId is required and cannot be empty', 400);\n    }\n    if (!accessToken?.trim()) {\n      throw new IOEventsApiError('accessToken is required and cannot be empty', 400);\n    }\n\n    this.restClient = new RestClient();\n    this.endpoint = IoEventsGlobals.BASE_URL;\n    this.consumerId = consumerId;\n    this.projectId = projectId;\n    this.workspaceId = workspaceId;\n    this.accessToken = accessToken;\n  }\n\n  /**\n   * Create a new registration\n   *\n   * @param registrationData - The registration data to create\n   * @returns Promise<Registration> - The created registration\n   * @throws IOEventsApiError - When the API call fails\n   *\n   * @example\n   * ```typescript\n   * const registration = await registrationManager.create({\n   *   client_id: 'your-client-id',\n   *   name: 'My Registration',\n   *   description: 'Registration for user events',\n   *   webhook_url: 'https://example.com/webhook',\n   *   events_of_interest: [\n   *     {\n   *       provider_id: 'provider-123',\n   *       event_code: 'com.example.user.created'\n   *     }\n   *   ],\n   *   delivery_type: 'webhook',\n   *   enabled: true\n   * });\n   * console.log(registration.registration_id);\n   * ```\n   */\n  async execute(registrationData: RegistrationCreateModel): Promise<Registration> {\n    try {\n      this.validateRegistrationInput(registrationData);\n\n      const url = `${this.endpoint}/events/${this.consumerId}/${this.projectId}/${this.workspaceId}/registrations`;\n\n      const response = await this.restClient.post(\n        url,\n        {\n          Authorization: `Bearer ${this.accessToken}`,\n          'x-api-key': this.consumerId,\n          'Content-Type': 'application/json',\n          Accept: 'application/hal+json',\n        },\n        registrationData\n      );\n\n      return response as Registration;\n    } catch (error) {\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Validates the registration input data\n   */\n  private validateRegistrationInput(registrationData: RegistrationCreateModel): void {\n    if (!registrationData) {\n      throw new IOEventsApiError('Registration data is required', 400);\n    }\n\n    if (!registrationData.client_id?.trim()) {\n      throw new IOEventsApiError('Client ID is required', 400);\n    }\n\n    if (registrationData.client_id.length < 3 || registrationData.client_id.length > 255) {\n      throw new IOEventsApiError('Client ID must be between 3 and 255 characters', 400);\n    }\n\n    if (!registrationData.name?.trim()) {\n      throw new IOEventsApiError('Registration name is required', 400);\n    }\n\n    if (registrationData.name.length < 3 || registrationData.name.length > 255) {\n      throw new IOEventsApiError('Registration name must be between 3 and 255 characters', 400);\n    }\n\n    if (registrationData.description && registrationData.description.length > 5000) {\n      throw new IOEventsApiError('Description must not exceed 5000 characters', 400);\n    }\n\n    if (registrationData.webhook_url && registrationData.webhook_url.length > 4000) {\n      throw new IOEventsApiError('Webhook URL must not exceed 4000 characters', 400);\n    }\n\n    if (\n      !registrationData.events_of_interest ||\n      !Array.isArray(registrationData.events_of_interest)\n    ) {\n      throw new IOEventsApiError('Events of interest is required and must be an array', 400);\n    }\n\n    if (registrationData.events_of_interest.length === 0) {\n      throw new IOEventsApiError('At least one event of interest is required', 400);\n    }\n\n    // Validate each event of interest\n    registrationData.events_of_interest.forEach((event, index) => {\n      if (!event.provider_id?.trim()) {\n        throw new IOEventsApiError(`Provider ID is required for event at index ${index}`, 400);\n      }\n      if (!event.event_code?.trim()) {\n        throw new IOEventsApiError(`Event code is required for event at index ${index}`, 400);\n      }\n    });\n\n    if (!registrationData.delivery_type?.trim()) {\n      throw new IOEventsApiError('Delivery type is required', 400);\n    }\n\n    const validDeliveryTypes = ['webhook', 'webhook_batch', 'journal', 'aws_eventbridge'];\n    if (!validDeliveryTypes.includes(registrationData.delivery_type)) {\n      throw new IOEventsApiError(\n        `Delivery type must be one of: ${validDeliveryTypes.join(', ')}`,\n        400\n      );\n    }\n\n    if (registrationData.runtime_action && registrationData.runtime_action.length > 255) {\n      throw new IOEventsApiError('Runtime action must not exceed 255 characters', 400);\n    }\n  }\n\n  /**\n   * Handles errors from the API call\n   */\n  private handleError(error: any): never {\n    // Re-throw validation errors as-is\n    if (error instanceof IOEventsApiError) {\n      throw error;\n    }\n\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    if (error.response?.status) {\n      const statusCode = error.response.status;\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    if (error.status) {\n      const statusCode = error.status;\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    throw new IOEventsApiError('Network error occurred', 500);\n  }\n\n  /**\n   * Extracts status code from HTTP error message\n   */\n  private extractStatusCodeFromMessage(message: string): number {\n    const match = message.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : 500;\n  }\n\n  /**\n   * Gets appropriate error message for HTTP status code\n   */\n  private getErrorMessageForStatus(statusCode: number): string {\n    switch (statusCode) {\n      case 400:\n        return 'Bad request: Invalid registration data provided';\n      case 401:\n        return 'Unauthorized: Invalid or missing authentication';\n      case 403:\n        return 'Forbidden: Insufficient permissions';\n      case 409:\n        return 'Conflict: Registration with this name already exists';\n      case 422:\n        return 'Unprocessable entity: Invalid registration data';\n      case 500:\n        return 'Internal server error';\n      default:\n        return `API error: HTTP ${statusCode}`;\n    }\n  }\n}\n\nexport default Create;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IoEventsGlobals } from '../../types';\n\n/**\n * Service for deleting registrations\n */\nexport class Delete {\n  private restClient: RestClient;\n  private endpoint: string;\n  private consumerId: string;\n  private projectId: string;\n  private workspaceId: string;\n  private accessToken: string;\n\n  /**\n   * Initialize the Delete service\n   */\n  constructor(\n    clientId: string,\n    consumerId: string,\n    projectId: string,\n    workspaceId: string,\n    accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new IOEventsApiError('clientId is required and cannot be empty', 400);\n    }\n    if (!consumerId?.trim()) {\n      throw new IOEventsApiError('consumerId is required and cannot be empty', 400);\n    }\n    if (!projectId?.trim()) {\n      throw new IOEventsApiError('projectId is required and cannot be empty', 400);\n    }\n    if (!workspaceId?.trim()) {\n      throw new IOEventsApiError('workspaceId is required and cannot be empty', 400);\n    }\n    if (!accessToken?.trim()) {\n      throw new IOEventsApiError('accessToken is required and cannot be empty', 400);\n    }\n\n    this.restClient = new RestClient();\n    this.endpoint = IoEventsGlobals.BASE_URL;\n    this.consumerId = consumerId;\n    this.projectId = projectId;\n    this.workspaceId = workspaceId;\n    this.accessToken = accessToken;\n  }\n\n  /**\n   * Delete a registration by ID\n   *\n   * @param registrationId - The registration ID to delete\n   * @returns Promise<void> - Resolves when deletion is successful\n   * @throws IOEventsApiError - When the API call fails\n   *\n   * @example\n   * ```typescript\n   * await registrationManager.delete('your-registration-id');\n   * console.log('Registration deleted successfully');\n   * ```\n   */\n  async execute(registrationId: string): Promise<void> {\n    try {\n      this.validateInputs(registrationId);\n\n      const url = `${this.endpoint}/events/${this.consumerId}/${this.projectId}/${this.workspaceId}/registrations/${registrationId}`;\n\n      await this.restClient.delete(url, {\n        Authorization: `Bearer ${this.accessToken}`,\n        'x-api-key': this.consumerId,\n        Accept: 'text/plain',\n      });\n\n      // Delete operation returns 204 No Content on success\n    } catch (error) {\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Validates the input parameters\n   */\n  private validateInputs(registrationId: string): void {\n    if (!registrationId?.trim()) {\n      throw new IOEventsApiError('Registration ID is required', 400);\n    }\n  }\n\n  /**\n   * Handles errors from the API call\n   */\n  private handleError(error: any): never {\n    if (error instanceof IOEventsApiError) {\n      throw error;\n    }\n\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    if (error.response?.status) {\n      const statusCode = error.response.status;\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    if (error.status) {\n      const statusCode = error.status;\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    throw new IOEventsApiError('Network error occurred', 500);\n  }\n\n  /**\n   * Extracts status code from HTTP error message\n   */\n  private extractStatusCodeFromMessage(message: string): number {\n    const match = message.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : 500;\n  }\n\n  /**\n   * Gets appropriate error message for HTTP status code\n   */\n  private getErrorMessageForStatus(statusCode: number): string {\n    switch (statusCode) {\n      case 400:\n        return 'Bad request: Invalid registration ID provided';\n      case 401:\n        return 'Unauthorized: Invalid or missing authentication';\n      case 403:\n        return 'Forbidden: Insufficient permissions';\n      case 404:\n        return 'Registration not found';\n      case 500:\n        return 'Internal server error';\n      default:\n        return `API error: HTTP ${statusCode}`;\n    }\n  }\n}\n\nexport default Delete;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IoEventsGlobals } from '../../types';\nimport type { Registration } from '../types';\n\n/**\n * Service for getting a specific registration by ID\n */\nexport class Get {\n  private restClient: RestClient;\n  private endpoint: string;\n  private consumerId: string;\n  private projectId: string;\n  private workspaceId: string;\n  private accessToken: string;\n\n  /**\n   * Initialize the Get service\n   */\n  constructor(\n    clientId: string,\n    consumerId: string,\n    projectId: string,\n    workspaceId: string,\n    accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new IOEventsApiError('clientId is required and cannot be empty', 400);\n    }\n    if (!consumerId?.trim()) {\n      throw new IOEventsApiError('consumerId is required and cannot be empty', 400);\n    }\n    if (!projectId?.trim()) {\n      throw new IOEventsApiError('projectId is required and cannot be empty', 400);\n    }\n    if (!workspaceId?.trim()) {\n      throw new IOEventsApiError('workspaceId is required and cannot be empty', 400);\n    }\n    if (!accessToken?.trim()) {\n      throw new IOEventsApiError('accessToken is required and cannot be empty', 400);\n    }\n\n    this.restClient = new RestClient();\n    this.endpoint = IoEventsGlobals.BASE_URL;\n    this.consumerId = consumerId;\n    this.projectId = projectId;\n    this.workspaceId = workspaceId;\n    this.accessToken = accessToken;\n  }\n\n  /**\n   * Get a registration by ID\n   *\n   * @param registrationId - The registration ID to retrieve\n   * @returns Promise<Registration> - The registration data\n   * @throws IOEventsApiError - When the API call fails\n   *\n   * @example\n   * ```typescript\n   * const registration = await registrationManager.get('your-registration-id');\n   * console.log(registration.name);\n   * ```\n   */\n  async execute(registrationId: string): Promise<Registration> {\n    try {\n      this.validateInputs(registrationId);\n\n      const url = `${this.endpoint}/events/${this.consumerId}/${this.projectId}/${this.workspaceId}/registrations/${registrationId}`;\n\n      const response = await this.restClient.get(url, {\n        Authorization: `Bearer ${this.accessToken}`,\n        'x-api-key': this.consumerId,\n        Accept: 'application/hal+json',\n      });\n\n      return response as Registration;\n    } catch (error) {\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Validates the input parameters\n   */\n  private validateInputs(registrationId: string): void {\n    if (!registrationId?.trim()) {\n      throw new IOEventsApiError('Registration ID is required', 400);\n    }\n  }\n\n  /**\n   * Handles errors from the API call\n   */\n  private handleError(error: any): never {\n    if (error instanceof IOEventsApiError) {\n      throw error;\n    }\n\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    if (error.response?.status) {\n      const statusCode = error.response.status;\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    if (error.status) {\n      const statusCode = error.status;\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    throw new IOEventsApiError('Network error occurred', 500);\n  }\n\n  /**\n   * Extracts status code from HTTP error message\n   */\n  private extractStatusCodeFromMessage(message: string): number {\n    const match = message.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : 500;\n  }\n\n  /**\n   * Gets appropriate error message for HTTP status code\n   */\n  private getErrorMessageForStatus(statusCode: number): string {\n    switch (statusCode) {\n      case 400:\n        return 'Bad request: Invalid parameters provided';\n      case 401:\n        return 'Unauthorized: Invalid or missing authentication';\n      case 403:\n        return 'Forbidden: Insufficient permissions';\n      case 404:\n        return 'Registration not found';\n      case 500:\n        return 'Internal server error';\n      default:\n        return `API error: HTTP ${statusCode}`;\n    }\n  }\n}\n\nexport default Get;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport RestClient from '../../../integration/rest-client';\nimport { IOEventsApiError, IoEventsGlobals } from '../../types';\nimport type { Registration } from '../types';\nimport type { RegistrationListResponse, ListRegistrationQueryParams } from './types';\n\n/**\n * Service for listing registrations with automatic pagination\n */\nexport class List {\n  private restClient: RestClient;\n  private endpoint: string;\n  private consumerId: string;\n  private projectId: string;\n  private workspaceId: string;\n  private accessToken: string;\n\n  /**\n   * Initialize the List service\n   */\n  constructor(\n    clientId: string,\n    consumerId: string,\n    projectId: string,\n    workspaceId: string,\n    accessToken: string\n  ) {\n    if (!clientId?.trim()) {\n      throw new IOEventsApiError('clientId is required and cannot be empty', 400);\n    }\n    if (!consumerId?.trim()) {\n      throw new IOEventsApiError('consumerId is required and cannot be empty', 400);\n    }\n    if (!projectId?.trim()) {\n      throw new IOEventsApiError('projectId is required and cannot be empty', 400);\n    }\n    if (!workspaceId?.trim()) {\n      throw new IOEventsApiError('workspaceId is required and cannot be empty', 400);\n    }\n    if (!accessToken?.trim()) {\n      throw new IOEventsApiError('accessToken is required and cannot be empty', 400);\n    }\n\n    this.restClient = new RestClient();\n    this.endpoint = IoEventsGlobals.BASE_URL;\n    this.consumerId = consumerId;\n    this.projectId = projectId;\n    this.workspaceId = workspaceId;\n    this.accessToken = accessToken;\n  }\n\n  /**\n   * Execute registration list with automatic pagination\n   */\n  async execute(queryParams?: ListRegistrationQueryParams): Promise<Registration[]> {\n    try {\n      this.validateInputs();\n\n      let url = `${this.endpoint}/events/${this.consumerId}/${this.projectId}/${this.workspaceId}/registrations`;\n\n      // Add query parameters if provided\n      if (queryParams && Object.keys(queryParams).length > 0) {\n        const searchParams = new URLSearchParams();\n        Object.entries(queryParams).forEach(([key, value]) => {\n          if (value !== undefined && value !== null) {\n            searchParams.append(key, String(value));\n          }\n        });\n        if (searchParams.toString()) {\n          url += `?${searchParams.toString()}`;\n        }\n      }\n\n      return await this.fetchAllPages(url);\n    } catch (error: any) {\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Fetch all pages recursively\n   */\n  private async fetchAllPages(\n    url: string,\n    accumulatedResults: Registration[] = []\n  ): Promise<Registration[]> {\n    const headers = {\n      Authorization: `Bearer ${this.accessToken}`,\n      'x-api-key': this.consumerId,\n      'Content-Type': 'application/json',\n    };\n\n    const data = (await this.restClient.get(url, headers)) as RegistrationListResponse;\n\n    // Extract registrations from current page\n    const currentPageRegistrations = data._embedded?.registrations || [];\n    const allResults = [...accumulatedResults, ...currentPageRegistrations];\n\n    // Check if there's a next page\n    const nextPageUrl = data._links?.next?.href;\n    if (nextPageUrl) {\n      // Recursively fetch the next page\n      return await this.fetchAllPages(nextPageUrl, allResults);\n    }\n\n    return allResults;\n  }\n\n  /**\n   * Validate required inputs\n   */\n  private validateInputs(): void {\n    if (!this.consumerId?.trim()) {\n      throw new IOEventsApiError(\n        'Consumer ID is required',\n        IoEventsGlobals.STATUS_CODES.BAD_REQUEST\n      );\n    }\n    if (!this.projectId?.trim()) {\n      throw new IOEventsApiError(\n        'Project ID is required',\n        IoEventsGlobals.STATUS_CODES.BAD_REQUEST\n      );\n    }\n    if (!this.workspaceId?.trim()) {\n      throw new IOEventsApiError(\n        'Workspace ID is required',\n        IoEventsGlobals.STATUS_CODES.BAD_REQUEST\n      );\n    }\n    if (!this.accessToken?.trim()) {\n      throw new IOEventsApiError(\n        'Access token is required',\n        IoEventsGlobals.STATUS_CODES.BAD_REQUEST\n      );\n    }\n  }\n\n  /**\n   * Handle and categorize errors\n   */\n  private handleError(error: any): never {\n    // Handle RestClient HTTP errors (e.g., \"HTTP error! status: 404\")\n    if (error instanceof Error && error.message.includes('HTTP error! status:')) {\n      const statusCode = this.extractStatusCodeFromMessage(error.message);\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    // Handle structured API error responses\n    if (error.response) {\n      const statusCode =\n        error.response.status || error.status || IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n      const errorMessage = this.getErrorMessageForStatus(statusCode);\n      throw new IOEventsApiError(errorMessage, statusCode);\n    }\n\n    // Handle other errors\n    if (error instanceof IOEventsApiError) {\n      throw error;\n    }\n\n    // Default error handling\n    throw new IOEventsApiError(\n      error.message || 'An unexpected error occurred while listing registrations',\n      IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR\n    );\n  }\n\n  /**\n   * Extract status code from error message\n   */\n  private extractStatusCodeFromMessage(errorMessage: string): number {\n    const match = errorMessage.match(/HTTP error! status:\\s*(\\d+)/);\n    return match ? parseInt(match[1]!, 10) : IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR;\n  }\n\n  /**\n   * Get appropriate error message for status code\n   */\n  private getErrorMessageForStatus(statusCode: number): string {\n    switch (statusCode) {\n      case IoEventsGlobals.STATUS_CODES.BAD_REQUEST:\n        return 'Bad request. Please check your input parameters';\n      case IoEventsGlobals.STATUS_CODES.UNAUTHORIZED:\n        return 'Unauthorized. Please check your access token';\n      case IoEventsGlobals.STATUS_CODES.FORBIDDEN:\n        return 'Forbidden. You do not have permission to access registrations';\n      case IoEventsGlobals.STATUS_CODES.NOT_FOUND:\n        return 'Registrations not found. The specified workspace may not exist or have no registrations';\n      case IoEventsGlobals.STATUS_CODES.INTERNAL_SERVER_ERROR:\n        return 'Internal server error. Please try again later';\n      default:\n        return `API request failed with status ${statusCode}`;\n    }\n  }\n}\n\nexport default List;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport Create from './create';\nimport Delete from './delete';\nimport Get from './get';\nimport List from './list';\nimport type { Registration } from './types';\nimport type { RegistrationCreateModel } from './create/types';\nimport type { ListRegistrationQueryParams } from './list/types';\n\n/**\n * Manager class for registration operations\n */\nexport class RegistrationManager {\n  private createService: Create;\n  private deleteService: Delete;\n  private getService: Get;\n  private listService: List;\n\n  /**\n   * Initialize the RegistrationManager\n   */\n  constructor(\n    clientId: string,\n    consumerId: string,\n    projectId: string,\n    workspaceId: string,\n    accessToken: string\n  ) {\n    this.createService = new Create(clientId, consumerId, projectId, workspaceId, accessToken);\n    this.deleteService = new Delete(clientId, consumerId, projectId, workspaceId, accessToken);\n    this.getService = new Get(clientId, consumerId, projectId, workspaceId, accessToken);\n    this.listService = new List(clientId, consumerId, projectId, workspaceId, accessToken);\n  }\n\n  /**\n   * Create a new registration\n   *\n   * @param registrationData - The registration data to create\n   * @returns Promise<Registration> - The created registration\n   *\n   * @example\n   * ```typescript\n   * const registration = await registrationManager.create({\n   *   client_id: 'your-client-id',\n   *   name: 'My Registration',\n   *   description: 'Registration for user events',\n   *   webhook_url: 'https://example.com/webhook',\n   *   events_of_interest: [\n   *     {\n   *       provider_id: 'provider-123',\n   *       event_code: 'com.example.user.created'\n   *     }\n   *   ],\n   *   delivery_type: 'webhook',\n   *   enabled: true\n   * });\n   * console.log(registration.registration_id);\n   * ```\n   */\n  async create(registrationData: RegistrationCreateModel): Promise<Registration> {\n    return await this.createService.execute(registrationData);\n  }\n\n  /**\n   * Delete a registration by ID\n   *\n   * @param registrationId - The registration ID to delete\n   * @returns Promise<void> - Resolves when deletion is successful\n   *\n   * @example\n   * ```typescript\n   * await registrationManager.delete('your-registration-id');\n   * console.log('Registration deleted successfully');\n   * ```\n   */\n  async delete(registrationId: string): Promise<void> {\n    return await this.deleteService.execute(registrationId);\n  }\n\n  /**\n   * Get a registration by ID\n   *\n   * @param registrationId - The registration ID to retrieve\n   * @returns Promise<Registration> - The registration data\n   *\n   * @example\n   * ```typescript\n   * const registration = await registrationManager.get('your-registration-id');\n   * console.log(registration.name);\n   * ```\n   */\n  async get(registrationId: string): Promise<Registration> {\n    return await this.getService.execute(registrationId);\n  }\n\n  /**\n   * List all registrations with automatic pagination\n   *\n   * @param queryParams - Optional query parameters for filtering\n   * @returns Promise<Registration[]> - Array of all registrations across all pages\n   *\n   * @example\n   * ```typescript\n   * // List all registrations\n   * const registrations = await registrationManager.list();\n   *\n   * // List with query parameters\n   * const filteredRegistrations = await registrationManager.list({\n   *   enabled: true\n   * });\n   * ```\n   */\n  async list(queryParams?: ListRegistrationQueryParams): Promise<Registration[]> {\n    return await this.listService.execute(queryParams);\n  }\n}\n\nexport default RegistrationManager;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAAA;AAAA,EAAA;AAAA;AAAA;;;ACIA,qBAAqB;;;ACAd,IAAK,aAAL,kBAAKC,gBAAL;AACL,EAAAA,wBAAA,QAAK,OAAL;AACA,EAAAA,wBAAA,iBAAc,OAAd;AACA,EAAAA,wBAAA,kBAAe,OAAf;AACA,EAAAA,wBAAA,eAAY,OAAZ;AACA,EAAAA,wBAAA,wBAAqB,OAArB;AACA,EAAAA,wBAAA,oBAAiB,OAAjB;AANU,SAAAA;AAAA,GAAA;AASL,IAAK,aAAL,kBAAKC,gBAAL;AACL,EAAAA,YAAA,SAAM;AACN,EAAAA,YAAA,UAAO;AACP,EAAAA,YAAA,SAAM;AACN,EAAAA,YAAA,YAAS;AACT,EAAAA,YAAA,WAAQ;AACR,EAAAA,YAAA,UAAO;AACP,EAAAA,YAAA,aAAU;AAPA,SAAAA;AAAA,GAAA;;;ACNZ,IAAM,yBAAN,MAAM,uBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS1B,OAAO,QACL,UACA,UAAqC,CAAC,GACrB;AACjB,WAAO;AAAA,MACL;AAAA,MACA,MAAM;AAAA,MACN;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,OAAO,MAAM,YAAwB,OAA8B;AACjE,WAAO;AAAA,MACL,OAAO;AAAA,QACL;AAAA,QACA,MAAM;AAAA,UACJ;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAvC4B;AAA5B,IAAM,wBAAN;AAyCA,IAAO,mBAAQ;;;AC5Cf,IAAM,cAAN,MAAM,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASf,OAAO,UAAU,QAAwC;AAEvD,QAAI,UAAU,OAAO,gBAAgB,CAAC;AACtC,QAAI,QAAQ,eAAe;AACzB,gBAAU,EAAE,GAAG,SAAS,eAAe,WAAW;AAAA,IACpD;AACA,WAAO,KAAK,UAAU,EAAE,GAAG,QAAQ,cAAc,QAAQ,CAAC;AAAA,EAC5D;AACF;AAjBiB;AAAjB,IAAM,aAAN;AAmBA,IAAO,qBAAQ;;;ACnBf,IAAM,aAAN,MAAM,WAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAad,OAAO,eAAe,KAA6B,UAA8B;AAC/E,WAAO,SAAS,OAAO,OAAK;AAC1B,YAAM,SAAS,EAAE,MAAM,GAAG;AAC1B,YAAM,OAAO,OAAO,OAAO,SAAS,CAAC;AACrC,YAAM,WAAW,OAAO,MAAM,GAAG,EAAE,EAAE,OAAO,CAAC,MAAM,UAAU,KAAK,KAAK,KAAK,CAAC,GAAG,GAAG;AACnF,aAAO,SAAS,SAAS,IAAI,MAAM,UAAa,SAAS,IAAI,MAAM;AAAA,IACrE,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,OAAO,0BACL,QACA,iBAA2B,CAAC,GAC5B,kBAA4B,CAAC,GACd;AACf,QAAI,eAA8B;AAGlC,sBAAkB,gBAAgB,IAAI,OAAK,EAAE,YAAY,CAAC;AAE1D,UAAM,oBAAoB,OAAO,KAAK,OAAO,gBAAgB,CAAC,CAAC,EAAE;AAAA,MAC/D,CAAC,KAAK,QAAQ;AACZ,YAAI,IAAI,YAAY,CAAC,IAAI,OAAO,eAAe,GAAG;AAClD,eAAO;AAAA,MACT;AAAA,MACA,CAAC;AAAA,IACH;AAEA,UAAM,iBAAiB,WAAU,eAAe,mBAAmB,eAAe;AAClF,QAAI,eAAe,SAAS,GAAG;AAC7B,qBAAe,sBAAsB,eAAe,KAAK,IAAI,CAAC;AAAA,IAChE;AAGA,UAAM,gBAAgB,WAAU,eAAe,QAAQ,cAAc;AACrE,QAAI,cAAc,SAAS,GAAG;AAC5B,UAAI,cAAc;AAChB,wBAAgB;AAAA,MAClB,OAAO;AACL,uBAAe;AAAA,MACjB;AACA,sBAAgB,yBAAyB,cAAc,KAAK,IAAI,CAAC;AAAA,IACnE;AAEA,WAAO;AAAA,EACT;AACF;AAvEgB;AAAhB,IAAM,YAAN;AAyEA,IAAO,oBAAQ;;;AJhEf,IAAM,iBAAN,MAAM,eAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASlB,OAAO,QACL,OAAe,QACf,cAA4B,CAAC,GAC7B,iBAA2B,CAAC,GAC5B,kBAA4B,CAAC,GAC7B,SAG0C,OACxC,YACuC;AACvC,WAAO,EAAE,0BAA2B,MAAM,CAAC,EAAE;AAAA,EAC/C,GACwE;AACxE,WAAO,OAAO,WAAmC;AAE/C,YAAM,SAAS,oBAAK,OAAO,MAAM,EAAE,OAAO,OAAO,aAAa,OAAO,CAAC;AAEtE,UAAI;AAEF,eAAO,KAAK,eAAe,IAAI,SAAS;AAGxC,eAAO,MAAM,mBAAW,UAAU,MAAM,CAAC;AAGzC,cAAM,kBAAkB,eAAc;AAAA,UACpC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AACA,YAAI,iBAAiB;AACnB,iBAAO;AAAA,QACT;AAEA,cAAM,SAAS,MAAM,OAAO,QAAQ,EAAE,QAAgB,SAAS,OAAO,gBAAgB,CAAC,EAAE,CAAC;AAE1F,eAAO,KAAK,MAAM;AAClB,eAAO;AAAA,MACT,SAAS,OAAO;AAEd,eAAO,MAAM,KAAK;AAElB,eAAO,iBAAsB,gCAAiC,cAAc;AAAA,MAC9E;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAe,gBACb,QACA,gBACA,iBACA,aACA,QACkC;AAElC,UAAM,eACJ,kBAAU,0BAA0B,QAAQ,gBAAgB,eAAe,KAAK;AAClF,QAAI,cAAc;AAEhB,aAAO,iBAAsB,6BAA8B,YAAY;AAAA,IACzE;AAGA,UAAM,gBAAgB,OAAO;AAC7B,QAAI,YAAY,SAAS,KAAK,CAAC,YAAY,SAAS,aAAa,GAAG;AAClE,YAAMC,gBAAe,wBAAwB,aAAa,0BAA0B,YAAY,KAAK,IAAI,CAAC;AAC1G,aAAO,MAAMA,aAAY;AACzB,aAAO,iBAAsB,oCAAqCA,aAAY;AAAA,IAChF;AAEA,WAAO;AAAA,EACT;AACF;AApFoB;AAApB,IAAM,gBAAN;AAsFA,IAAO,yBAAQ;;;AK7Ff,IAAAC,kBAAqB;AASrB,IAAM,uBAAN,MAAM,qBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQxB,OAAO,QACL,OAAe,QACf,iBAA2B,CAAC,GAC5B,kBAA4B,CAAC,GAC7B,SAG0C,OACxC,YACuC;AACvC,WAAO,EAAE,0BAA2B,MAAM,CAAC,EAAE;AAAA,EAC/C,GACwE;AACxE,WAAO,OAAO,WAAmC;AAE/C,YAAM,SAAS,qBAAK,OAAO,MAAM,EAAE,OAAO,OAAO,aAAa,OAAO,CAAC;AAEtE,UAAI;AAEF,eAAO,KAAK,eAAe,IAAI,SAAS;AAGxC,eAAO,MAAM,mBAAW,UAAU,MAAM,CAAC;AAGzC,cAAM,eACJ,kBAAU,0BAA0B,QAAQ,gBAAgB,eAAe,KAAK;AAClF,YAAI,cAAc;AAEhB,iBAAO,iBAAsB,6BAA8B,YAAY;AAAA,QACzE;AAEA,cAAM,SAAS,MAAM,OAAO,QAAQ,EAAE,QAAgB,SAAS,OAAO,gBAAgB,CAAC,EAAE,CAAC;AAE1F,eAAO,KAAK,MAAM;AAClB,eAAO;AAAA,MACT,SAAS,OAAO;AAEd,eAAO,MAAM,KAAK;AAElB,eAAO,iBAAsB,gCAAiC,cAAc;AAAA,MAC9E;AAAA,IACF;AAAA,EACF;AACF;AApD0B;AAA1B,IAAM,sBAAN;AAsDA,IAAO,gCAAQ;;;AC/Df,qBAAsD;AAQtD,IAAM,iBAAN,MAAM,eAAc;AAAA,EAClB,OAAO,QACL,SAAiB;AAAA;AAAA;AAAA;AAAA,OAKjB,YAIqB,OAAO,YAA0B;AACpD,WAAO;AAAA,MACL,OAAO,6BAAc,gBAAd;AAAA,IACT;AAAA,EACF,GACA,OAAe,QACf,uBAAgC,OACwC;AACxE,WAAO,uBAAc;AAAA,MACnB,WAAW,IAAI;AAAA,MACf,mCAAgC;AAAA,MAChC,CAAC,OAAO;AAAA,MACR,CAAC;AAAA,MACD,OAAO,QAAQ,QAAQ;AACrB,YAAI;AACJ,YAAI;AACF,8BAAgB,4BAAY,MAAM;AAAA,QACpC,SAAS,OAAO;AACd,iBAAO,iBAAsB,6BAA+B,MAAgB,OAAO;AAAA,QACrF;AACA,cAAM,mBAAmB,MAAM,UAAU;AAAA,UACvC,GAAG;AAAA,UACH,GAAG;AAAA,YACD;AAAA,UACF;AAAA,QACF,CAAC;AAED,cAAMC,WAAU,CAAC;AACjB,cAAM,QAAQ,OAAO;AAErB,YAAI;AACJ,YAAI;AACF,4BAAc,sBAAM,KAAK;AAAA,QAC3B,SAAS,OAAO;AACd,iBAAO,iBAAsB,6BAA+B,MAAgB,OAAO;AAAA,QACrF;AAEA,cAAM,uBAAmB,yBAAS,eAAe,WAAW;AAC5D,YAAI,iBAAiB,QAAQ;AAC3B,iBAAO,iBAAsB;AAAA;AAAA,YAE3B,iBAAiB,IAAI,SAAO,IAAI,OAAO,EAAE,KAAK,IAAI;AAAA,UACpD;AAAA,QACF;AAEA,YAAI,sBAAsB;AAExB,gBAAM,uBAAuB,YAAY,YAAY;AAAA,YAAK,CAAC,eACzD,WAAW,aAAa,WAAW;AAAA,cAAK,CAAC,cACvC,UAAU,KAAK,MAAM,WAAW,IAAI;AAAA,YACtC;AAAA,UACF;AACA,cAAI,sBAAsB;AAExB,mBAAO,iBAAsB;AAAA;AAAA,cAE3B;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,cAAM,YACJ,OAAO,OAAO,cAAc,WAAW,KAAK,MAAM,OAAO,SAAS,IAAI,OAAO;AAE/E,eAAO,iBAAsB;AAAA,UAC3B,UAAM,wBAAQ;AAAA,YACZ,QAAQ;AAAA,YACR,QAAQ;AAAA,YACR,WAAW;AAAA,YACX,cAAcA;AAAA,YACd,gBAAgB;AAAA,YAChB,eAAe,OAAO;AAAA,UACxB,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAxFoB;AAApB,IAAM,gBAAN;AA0FA,IAAO,yBAAQ;;;AClGf,aAAwB;;;ACAjB,IAAK,mBAAL,kBAAKC,sBAAL;AACL,EAAAA,kBAAA,aAAU;AACV,EAAAA,kBAAA,eAAY;AACZ,EAAAA,kBAAA,SAAM;AACN,EAAAA,kBAAA,aAAU;AACV,EAAAA,kBAAA,YAAS;AALC,SAAAA;AAAA,GAAA;;;ACSZ,IAAM,yBAAN,MAAM,uBAAsB;AAAA,EAC1B,OAAO,UAA2B;AAChC,WAAO;AAAA,MACL;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,UAAU,gBAAyB,SAAqC;AAC7E,WAAO;AAAA,MACL;AAAA,MACA,OAAO;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,IAAI,MAAc,OAAY,UAAgC;AACnE,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,QAAQ,MAAc,OAAY,UAAoC;AAC3E,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,OAAO,MAA8B;AAC1C,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAvC4B;AAA5B,IAAM,wBAAN;AAyCA,IAAOC,oBAAQ;;;AClDR,IAAK,wBAAL,kBAAKC,2BAAL;AACL,EAAAA,8CAAA,cAAW,KAAX;AACA,EAAAA,8CAAA,aAAU,KAAV;AACA,EAAAA,8CAAA,yBAAsB,KAAtB;AAHU,SAAAA;AAAA,GAAA;;;AHcZ,IAAM,iBAAN,MAAM,eAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASlB,OAAO,QACL,OAAe,QACf,iBAA2B,CAAC,GAC5B,kBAA4B,CAAC,eAAe,GAC5C,0CACA,SAG0C,OACxC,YACuC;AACvC,WAAO,EAAE,0BAA2B,MAAM,CAAC,EAAE;AAAA,EAC/C,GACwE;AACxE,WAAO,uBAAc;AAAA,MACnB,WAAW,IAAI;AAAA,MACf,mCAAgC;AAAA,MAChC,CAAC;AAAA,MACD,CAAC;AAAA,MACD,OAAO,QAAQ,QAAQ;AACrB,cAAM,aAAa,CAAC;AAEpB,YAAI,OAAO,cAAc,MAAM;AAC7B,cAAI,UAAU,CAAC;AACf,cAAI;AACF,sBAAU,KAAK,MAAM,KAAK,OAAO,SAAS,CAAC;AAAA,UAC7C,QAAQ;AAAA,UAER;AACA,mBAAS;AAAA,YACP,GAAG;AAAA,YACH,GAAG;AAAA,UACL;AAEA,cAAI,OAAO,MAAM,mBAAW,UAAU,OAAO,CAAC;AAAA,QAChD;AAEA,YAAI,4CAA0D;AAC5D,cAAI,OAAO,eAAe,QAAW;AACnC,uBAAW;AAAA,cACTC,kBAAsB;AAAA,gBACpB;AAAA,gBACA;AAAA,cACF;AAAA,YACF;AAAA,UACF,OAAO;AAEL,kBAAM,eACJ,kBAAU,0BAA0B,QAAQ,gBAAgB,eAAe,KAAK;AAClF,gBAAI,cAAc;AAEhB,qBAAO,iBAAsB,6BAA8B,YAAY;AAAA,YACzE;AAEA,kBAAM,YAAiB,OAAO,aAAa,oCAAoC,KAAK;AACpF,kBAAM,WAA0B,oBAAa,QAAQ;AACrD,qBAAS,OAAO,OAAO,SAAS;AAEhC,gBAAI,YAAoB,OAAO;AAC/B,gBAAI,uDAAqE;AACvE,0BAAY,KAAK,SAAS;AAAA,YAC5B;AAEA,kBAAM,mBAAmB,SAAS,OAAO,WAAW,WAAW,QAAQ;AAEvE,gBAAI,kBAAkB;AACpB,yBAAW,KAAK,MAAM,OAAO,QAAQ,GAAG,CAAC;AAAA,YAC3C,OAAO;AACL,yBAAW;AAAA,gBACTA,kBAAsB;AAAA,kBACpB;AAAA,kBACA;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF,OAAO;AAEL,gBAAM,eACJ,kBAAU,0BAA0B,QAAQ,gBAAgB,eAAe,KAAK;AAClF,cAAI,cAAc;AAEhB,mBAAO,iBAAsB,6BAA8B,YAAY;AAAA,UACzE;AAEA,qBAAW,KAAK,MAAM,OAAO,QAAQ,GAAG,CAAC;AAAA,QAC3C;AAEA,eAAO,iBAAsB,QAAQ,KAAK,UAAU,UAAU,CAAC;AAAA,MACjE;AAAA,IACF;AAAA,EACF;AACF;AArGoB;AAApB,IAAM,gBAAN;AAuGA,IAAO,yBAAQ;;;AIrHf,uBAA4C;AAE5C,IAAM,aAAN,MAAM,WAAU;AAAA;AAAA;AAAA;AAAA;AAAA,EAUd,YAAY,MAAc,QAAgB;AACxC,SAAK,sBAAkB,iBAAAC,SAAU,EAAE,SAAS,MAAM,SAAS,OAAO,CAAC;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,QAAQ,QAAgB,QAAyC;AACrE,WAAO,MAAM,KAAK,gBAAgB,QAAQ,OAAO;AAAA,MAC/C,MAAM;AAAA,MACN,UAAU;AAAA,MACV;AAAA,IACF,CAAC;AAAA,EACH;AACF;AA1BgB;AAAhB,IAAM,YAAN;AA4BA,IAAO,oBAAQ;;;AC7Bf,IAAAC,kBAAqB;AAQrB,IAAM,mBAAN,MAAM,iBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMpB,OAAO,QACL,OAAe,QACf,SAG0C,OACxC,YACuC;AACvC,WAAO,EAAE,0BAA2B,MAAM,CAAC,EAAE;AAAA,EAC/C,GACwE;AACxE,WAAO,OAAO,WAAmC;AAE/C,YAAM,SAAS,qBAAK,OAAO,MAAM,EAAE,OAAO,OAAO,aAAa,OAAO,CAAC;AAEtE,UAAI;AAEF,eAAO,KAAK,eAAe,IAAI,iBAAiB;AAGhD,eAAO,MAAM,mBAAW,UAAU,MAAM,CAAC;AAEzC,cAAM,SAAS,MAAM,OAAO,QAAQ,EAAE,QAAgB,SAAS,OAAO,gBAAgB,CAAC,EAAE,CAAC;AAE1F,eAAO,KAAK,MAAM;AAClB,eAAO;AAAA,MACT,SAAS,OAAO;AAEd,eAAO,MAAM,KAAK;AAElB,eAAO,iBAAsB,gCAAiC,cAAc;AAAA,MAC9E;AAAA,IACF;AAAA,EACF;AACF;AAxCsB;AAAtB,IAAM,kBAAN;AA0CA,IAAO,2BAAQ;;;AClDf,IAAM,eAAN,MAAM,aAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBhB,OAAO,QAAQ,QAAoD;AACjE,QAAI,OAAO,cAAc,eAAe,WAAW,SAAS,GAAG;AAC7D,aAAO,OAAO,aAAa,cAAc,UAAU,UAAU,MAAM;AAAA,IACrE;AACA,WAAO;AAAA,EACT;AACF;AAvBkB;AAAlB,IAAM,cAAN;AAyBA,IAAO,uBAAQ;;;AC5Bf,wBAA6C;AAG7C,IAAM,cAAN,MAAM,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQf,MAAM,IAAI,UAAkB,UAAmB,CAAC,GAAiB;AAC/D,WAAO,MAAM,KAAK,QAAQ,UAAU,OAAO,OAAO;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,KAAK,UAAkB,UAAmB,CAAC,GAAG,UAAe,MAAoB;AACrF,WAAO,MAAM,KAAK,QAAQ,UAAU,QAAQ,SAAS,OAAO;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,IAAI,UAAkB,UAAmB,CAAC,GAAG,UAAe,MAAoB;AACpF,WAAO,MAAM,KAAK,QAAQ,UAAU,OAAO,SAAS,OAAO;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,OAAO,UAAkB,UAAmB,CAAC,GAAiB;AAClE,WAAO,MAAM,KAAK,QAAQ,UAAU,UAAU,OAAO;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,QACJ,UACA,SAAiB,QACjB,UAAmB,CAAC,GACpB,UAAe,MACD;AACd,QAAI,UAAuB;AAAA,MACzB;AAAA,MACA;AAAA,IACF;AAEA,QAAI,YAAY,MAAM;AACpB,gBAAU;AAAA,QACR,GAAG;AAAA,QACH,MAAM,KAAK,UAAU,OAAO;AAAA,QAC5B,SAAS;AAAA,UACP,GAAG;AAAA,UACH,gBAAgB;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AAEA,UAAM,WAAqB,UAAM,kBAAAC,SAAM,UAAU,OAAO;AAExD,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,IAAI,MAAM,uBAAuB,SAAS,MAAM,EAAE;AAAA,IAC1D;AAGA,QAAI,SAAS,WAAW,OAAO,SAAS,SAAS,IAAI,gBAAgB,MAAM,KAAK;AAC9E,aAAO;AAAA,IACT;AAGA,QAAI,OAAO,SAAS,SAAS,YAAY;AACvC,YAAM,cAAc,SAAS,SAAS,IAAI,cAAc;AAExD,UACE,CAAC,eACD,YAAY,SAAS,kBAAkB,KACvC,YAAY,SAAS,sBAAsB,GAC3C;AACA,eAAO,MAAM,SAAS,KAAK;AAAA,MAC7B;AAAA,IACF;AAGA,QAAI,OAAO,SAAS,SAAS,YAAY;AACvC,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,aAAO;AAAA,IACT;AAGA,WAAO;AAAA,EACT;AACF;AA/GiB;AAAjB,IAAM,aAAN;AAiHA,IAAO,sBAAQ;;;ACpHf,yBAAkC;AAMlC,IAAM,aAAN,MAAM,WAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBd,aAAa,SACX,UACA,cACA,oBACA,uBACA,UACA,QACA,iBAAyB,qBACR;AACjB,UAAM,SAAyB;AAAA,MAC7B,WAAW;AAAA,MACX,gBAAgB,CAAC,YAAY;AAAA,MAC7B,sBAAsB;AAAA,MACtB,yBAAyB;AAAA,MACzB,YAAY;AAAA,MACZ;AAAA,IACF;AAEA,UAAM,2BAAQ,WAAW,cAAc;AACvC,UAAM,2BAAQ,IAAI,gBAAgB,MAAM;AAExC,WAAO,UAAM,6BAAS;AAAA,EACxB;AACF;AA9CgB;AAAhB,IAAM,YAAN;AAgDA,IAAO,qBAAQ;;;ACtDf,IAAAC,kBAAqB;AACrB,iBAAyB;AAKzB,IAAM,uBAAN,MAAM,qBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUxB,YAAY,SAAiB,YAAwB,SAAc,MAAM;AACvE,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD;AACA,SAAK,UAAU;AACf,SAAK,aAAa;AAElB,QAAI,WAAW,MAAM;AACnB,eAAS,qBAAK,OAAO,yBAAyB;AAAA,QAC5C,OAAO;AAAA,MACT,CAAC;AAAA,IACH;AACA,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,IAAI,UAAkB,UAAkC,CAAC,GAAiB;AAC9E,WAAO,MAAM,KAAK,QAAQ,UAAU,OAAO,OAAO;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,KACJ,UACA,UAAkC,CAAC,GACnC,UAAe,MACD;AACd,WAAO,MAAM,KAAK,QAAQ,UAAU,QAAQ,SAAS,OAAO;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,IACJ,UACA,UAAkC,CAAC,GACnC,UAAe,MACD;AACd,WAAO,MAAM,KAAK,QAAQ,UAAU,OAAO,SAAS,OAAO;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,OAAO,UAAkB,UAAkC,CAAC,GAAiB;AACjF,WAAO,MAAM,KAAK,QAAQ,UAAU,UAAU,OAAO;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,QACZ,UACA,SAAiB,QACjB,UAAkC,CAAC,GACnC,UAAe,MACD;AACd,UAAM,cAAc,MAAM,KAAK,cAAc;AAE7C,gBAAY,OAAO;AAAA,MACjB;AAAA,IACF,CAAC;AAED,UAAM,UAAU,8BAAO,aAA+C;AACpE,UAAI;AACF,cAAM,UAAU,MAAM,SAAS;AAC/B,eAAO,EAAE,SAAS,MAAM,QAAQ;AAAA,MAClC,SAAS,GAAQ;AACf,YAAI,EAAE,SAAS,yBAAyB;AACtC,eAAK,OAAO,MAAM,oCAAoC,CAAC;AACvD,iBAAO;AAAA,YACL,SAAS;AAAA,YACT;AAAA,YACA,SAAS,iDAAiD,EAAE,OAAO;AAAA,UACrE;AAAA,QACF;AACA,eAAO;AAAA,UACL,SAAS;AAAA,UACT,YAAY,EAAE,UAAU;AAAA,UACxB,SAAS,EAAE;AAAA,UACX,MAAO,EAA2B;AAAA,QACpC;AAAA,MACF;AAAA,IACF,GApBgB;AAsBhB,QAAI,UAAe;AAAA,MACjB;AAAA,IACF;AAEA,QAAI,YAAY,MAAM;AACpB,gBAAU;AAAA,QACR,GAAG;AAAA,QACH,MAAM;AAAA,MACR;AAAA,IACF;AAEA,WAAO,MAAM,QAAQ,MAAM,YAAY,UAAU,OAAO,EAAE,KAAK,CAAC;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAA8B;AAC1C,UAAM,cAAc,WAAAC,QAAI,OAAO;AAAA,MAC7B,OAAO;AAAA,MACP,cAAc;AAAA,MACd,WAAW,KAAK;AAAA,MAChB,SAAS;AAAA,QACP,gBAAgB;AAAA,MAClB;AAAA,MACA,OAAO;AAAA,QACL,eAAe;AAAA,UACb,CAAC,YAAkB,KAAK,OAAO,MAAM,YAAY,QAAQ,MAAM,KAAK,QAAQ,GAAG,EAAE;AAAA,QACnF;AAAA,QACA,aAAa;AAAA,UACX,CAAC,SAAS,OAAO,eACf,KAAK,OAAO;AAAA,YACV,qBAAqB,QAAQ,MAAM,KAAK,QAAQ,GAAG,aAAa,UAAU,aAAa,OAAO,IAAI,MAAM,OAAO,OAAO;AAAA,UACxH;AAAA,QACJ;AAAA,QACA,aAAa;AAAA,UACX,CAAC,UAAsD;AACrD,kBAAM,EAAE,SAAS,IAAI;AACrB,gBAAI,UAAU,MAAM;AAClB,oBAAM,eAAe,SAAS;AAAA,YAChC;AACA,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,QACA,eAAe;AAAA,UACb,CAAC,aAAkB;AACjB,iBAAK,OAAO;AAAA,cACV,aAAa,SAAS,QAAQ,QAAQ,MAAM,KAAK,SAAS,QAAQ,QAAQ,GAAG,MAAM,SAAS,UAAU,IAAI,SAAS,aAAa;AAAA,YAClI;AACA,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,WAAO,MAAM,KAAK,WAAW,OAAO,WAAW;AAAA,EACjD;AACF;AArK0B;AAA1B,IAAM,sBAAN;AAuKA,IAAO,gCAAQ;;;AC1KR,IAAM,kBAAkB;AAAA,EAC7B,UAAU;AAAA,EACV,cAAc;AAAA,IACZ,IAAI;AAAA,IACJ,aAAa;AAAA,IACb,cAAc;AAAA,IACd,WAAW;AAAA,IACX,WAAW;AAAA,IACX,iBAAiB;AAAA,IACjB,SAAS;AAAA,IACT,UAAU;AAAA,IACV,uBAAuB;AAAA,EACzB;AAAA,EACA,SAAS;AAAA,IACP,gBAAgB;AAAA,EAClB;AACF;AAyBO,IAAM,oBAAN,MAAM,0BAAyB,MAAM;AAAA,EAK1C,YAAY,SAAiB,YAAoB,WAAoB,SAAkB;AACrF,UAAM,OAAO;AACb,SAAK,OAAO;AACZ,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,UAAU;AAAA,EACjB;AACF;AAZ4C;AAArC,IAAM,mBAAN;;;AChCP,IAAM,QAAN,MAAM,MAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaT,YACmB,UACA,YACA,WACA,aACA,aACjB;AALiB;AACA;AACA;AACA;AACA;AAjBnB,SAAiB,WAAmB,gBAAgB;AAmBlD,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAEA,SAAK,aAAa,IAAI,oBAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,MAAM,QAAQ,cAAwC,CAAC,GAAwB;AAC7E,QAAI;AAEF,UAAI,YAAY,sBAAsB,YAAY,qBAAqB;AACrE,cAAM,IAAI,MAAM,gEAAgE;AAAA,MAClF;AAGA,YAAM,MAAM,GAAG,KAAK,QAAQ,WAAW,KAAK,UAAU;AAGtD,YAAM,cAAc,KAAK,iBAAiB,WAAW;AACrD,YAAM,UAAU,cAAc,GAAG,GAAG,IAAI,WAAW,KAAK;AAGxD,YAAM,UAAU;AAAA,QACd,eAAe,UAAU,KAAK,WAAW;AAAA,QACzC,aAAa,KAAK;AAAA,QAClB,QAAQ;AAAA,MACV;AAEA,aAAO,MAAM,KAAK,cAAc,SAAS,OAAO;AAAA,IAClD,SAAS,OAAY;AAEnB,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAc,cACZ,KACA,SACA,qBAAiC,CAAC,GACb;AAErB,UAAM,WAAkC,MAAM,KAAK,WAAW,IAAI,KAAK,OAAO;AAG9E,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC/C,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AAEA,QAAI,OAAO,aAAa,UAAU;AAChC,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AAGA,UAAM,YAAY,SAAS,WAAW;AAEtC,QAAI,cAAc,UAAa,CAAC,MAAM,QAAQ,SAAS,GAAG;AACxD,YAAM,IAAI,MAAM,uDAAuD;AAAA,IACzE;AAGA,UAAM,qBAAqB,aAAa,CAAC;AAGzC,UAAM,aAAa,CAAC,GAAG,oBAAoB,GAAG,kBAAkB;AAGhE,UAAM,cAAc,SAAS,QAAQ,MAAM;AAE3C,QAAI,aAAa;AAEf,aAAO,MAAM,KAAK,cAAc,aAAa,SAAS,UAAU;AAAA,IAClE;AAGA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,YAAY,OAAmB;AAErC,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAM,aAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAGA,QAAI,MAAM,UAAU,MAAM;AACxB,YAAM,YAA2B,MAAM,SAAS;AAChD,YAAM,aACJ,MAAM,SAAS,cAAc,gBAAgB,aAAa;AAC5D,YAAM,UACJ,UAAU,WAAW,UAAU,SAAS,KAAK,yBAAyB,UAAU;AAClF,YAAM,IAAI,iBAAiB,SAAS,YAAY,UAAU,YAAY,UAAU,OAAO;AAAA,IACzF;AAGA,QAAI,MAAM,SAAS,eAAe,MAAM,SAAS,gBAAgB;AAC/D,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAGA,QAAI,MAAM,SAAS,aAAa;AAC9B,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAGA,QAAI,MAAM,SAAS,SAAS,MAAM,KAAK,MAAM,SAAS,eAAe;AACnE,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAGA,QACE,MAAM,SAAS,SAAS,qBAAqB,KAC7C,MAAM,SAAS,SAAS,yBAAyB,GACjD;AACA,YAAM,IAAI;AAAA,QACR,MAAM;AAAA,QACN,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,UAAM,IAAI;AAAA,MACR,6BAA6B,MAAM,WAAW,wBAAwB;AAAA,MACtE,gBAAgB,aAAa;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,6BAA6B,cAA8B;AACjE,UAAM,QAAQ,aAAa,MAAM,6BAA6B;AAC9D,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI,gBAAgB,aAAa;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,yBAAyB,YAA4B;AAC3D,YAAQ,YAAY;AAAA,MAClB,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT;AACE,eAAO,mBAAmB,UAAU;AAAA,IACxC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,iBAAiB,QAA0C;AACjE,UAAM,aAAuB,CAAC;AAG9B,QAAI,OAAO,oBAAoB;AAC7B,iBAAW,KAAK,sBAAsB,mBAAmB,OAAO,kBAAkB,CAAC,EAAE;AAAA,IACvF;AAGA,QAAI,OAAO,YAAY;AACrB,iBAAW,KAAK,cAAc,mBAAmB,OAAO,UAAU,CAAC,EAAE;AAAA,IACvE;AAGA,QAAI,OAAO,uBAAuB,MAAM,QAAQ,OAAO,mBAAmB,GAAG;AAC3E,aAAO,oBAAoB,QAAQ,CAAC,OAAe;AACjD,mBAAW,KAAK,uBAAuB,mBAAmB,EAAE,CAAC,EAAE;AAAA,MACjE,CAAC;AAAA,IACH;AAGA,QAAI,OAAO,OAAO,kBAAkB,WAAW;AAC7C,iBAAW,KAAK,iBAAiB,OAAO,aAAa,EAAE;AAAA,IACzD;AAEA,WAAO,WAAW,KAAK,GAAG;AAAA,EAC5B;AACF;AA3QW;AAAX,IAAM,OAAN;AA6QA,IAAO,eAAQ;;;AC9Qf,IAAM,OAAN,MAAM,KAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaR,YACmB,UACA,YACA,WACA,aACA,aACjB;AALiB;AACA;AACA;AACA;AACA;AAjBnB,SAAiB,WAAmB,gBAAgB;AAmBlD,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAEA,SAAK,aAAa,IAAI,oBAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,MAAM,QAAQ,YAAoB,cAAsC,CAAC,GAAsB;AAC7F,QAAI;AAEF,UAAI,CAAC,YAAY,KAAK,GAAG;AACvB,cAAM,IAAI,MAAM,6CAA6C;AAAA,MAC/D;AAGA,YAAM,MAAM,GAAG,KAAK,QAAQ,qBAAqB,mBAAmB,UAAU,CAAC;AAG/E,YAAM,cAAc,KAAK,iBAAiB,WAAW;AACrD,YAAM,UAAU,cAAc,GAAG,GAAG,IAAI,WAAW,KAAK;AAGxD,YAAM,UAAU;AAAA,QACd,eAAe,UAAU,KAAK,WAAW;AAAA,QACzC,aAAa,KAAK;AAAA,QAClB,QAAQ;AAAA,MACV;AAGA,YAAM,WAAqB,MAAM,KAAK,WAAW,IAAI,SAAS,OAAO;AAGrE,UAAI,aAAa,QAAQ,aAAa,QAAW;AAC/C,cAAM,IAAI,MAAM,mDAAmD;AAAA,MACrE;AACA,UAAI,OAAO,aAAa,UAAU;AAChC,cAAM,IAAI,MAAM,mDAAmD;AAAA,MACrE;AAEA,aAAO;AAAA,IACT,SAAS,OAAY;AACnB,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,iBAAiB,aAA6C;AACpE,UAAM,SAAS,IAAI,gBAAgB;AAGnC,QAAI,YAAY,kBAAkB,QAAW;AAC3C,aAAO,OAAO,iBAAiB,OAAO,YAAY,aAAa,CAAC;AAAA,IAClE;AAEA,WAAO,OAAO,SAAS;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY,OAAmB;AAErC,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAM,aAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAE7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAGA,QAAI,MAAM,UAAU;AAClB,YAAM,SAAS,KAAK,kBAAkB,KAAK;AAC3C,YAAM,eAAe,KAAK,yBAAyB,MAAM;AACzD,YAAM,IAAI,iBAAiB,cAAc,QAAQ,WAAW;AAAA,IAC9D;AAGA,QAAI,MAAM,SAAS,eAAe,MAAM,SAAS,gBAAgB;AAC/D,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,QAAI,MAAM,SAAS,aAAa;AAC9B,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,QAAI,MAAM,SAAS,SAAS,MAAM,GAAG;AACnC,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,QACE,MAAM,SAAS,SAAS,yBAAyB,KACjD,MAAM,SAAS,SAAS,yBAAyB,GACjD;AACA,YAAM,IAAI;AAAA,QACR,MAAM;AAAA,QACN,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,UAAM,IAAI;AAAA,MACR,qBAAqB,MAAM,WAAW,wBAAwB;AAAA,MAC9D,gBAAgB,aAAa;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkB,OAAoB;AAC5C,WACE,MAAM,UAAU,UAAU,MAAM,UAAU,gBAAgB,aAAa;AAAA,EAE3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,6BAA6B,cAA8B;AACjE,UAAM,QAAQ,aAAa,MAAM,6BAA6B;AAC9D,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI,gBAAgB,aAAa;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA,EAKQ,yBAAyB,QAAwB;AACvD,YAAQ,QAAQ;AAAA,MACd,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT;AACE,eAAO,QAAQ,MAAM;AAAA,IACzB;AAAA,EACF;AACF;AAtNU;AAAV,IAAM,MAAN;AAwNA,IAAO,cAAQ;;;ACxNf,IAAM,UAAN,MAAM,QAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaX,YACmB,UACA,YACA,WACA,aACA,aACjB;AALiB;AACA;AACA;AACA;AACA;AAjBnB,SAAiB,WAAmB,gBAAgB;AAmBlD,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAEA,SAAK,aAAa,IAAI,oBAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,QAAQ,cAAqD;AACjE,QAAI;AAEF,UAAI,CAAC,cAAc;AACjB,cAAM,IAAI,MAAM,0BAA0B;AAAA,MAC5C;AACA,UAAI,CAAC,aAAa,OAAO,KAAK,GAAG;AAC/B,cAAM,IAAI,MAAM,mCAAmC;AAAA,MACrD;AAGA,YAAM,MAAM,GAAG,KAAK,QAAQ,WAAW,KAAK,UAAU,IAAI,KAAK,SAAS,IAAI,KAAK,WAAW;AAG5F,YAAM,UAAU;AAAA,QACd,eAAe,UAAU,KAAK,WAAW;AAAA,QACzC,aAAa,KAAK;AAAA,QAClB,QAAQ;AAAA,QACR,gBAAgB;AAAA,MAClB;AAGA,YAAM,WAAqB,MAAM,KAAK,WAAW,KAAK,KAAK,SAAS,YAAY;AAGhF,UAAI,aAAa,QAAQ,aAAa,QAAW;AAC/C,cAAM,IAAI,MAAM,mDAAmD;AAAA,MACrE;AAEA,UAAI,OAAO,aAAa,UAAU;AAChC,cAAM,IAAI,MAAM,mDAAmD;AAAA,MACrE;AAGA,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,IAAI,MAAM,8CAA8C;AAAA,MAChE;AAEA,aAAO;AAAA,IACT,SAAS,OAAY;AAEnB,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,YAAY,OAAmB;AAErC,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAM,aAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAGA,QAAI,MAAM,UAAU,MAAM;AACxB,YAAM,YAAY,MAAM,SAAS;AACjC,YAAM,aACJ,MAAM,SAAS,cAAc,gBAAgB,aAAa;AAC5D,YAAM,UACJ,UAAU,WAAW,UAAU,SAAS,KAAK,yBAAyB,UAAU;AAGlF,UACE,eAAe,gBAAgB,aAAa,YAC5C,MAAM,SAAS,UAAU,gBAAgB,QAAQ,cAAc,GAC/D;AACA,cAAM,gBAAgB,MAAM,SAAS,QAAQ,gBAAgB,QAAQ,cAAc;AACnF,cAAM,IAAI;AAAA,UACR,gDAAgD,aAAa;AAAA,UAC7D;AAAA,UACA;AAAA,UACA,4BAA4B,aAAa;AAAA,QAC3C;AAAA,MACF;AAEA,YAAM,IAAI,iBAAiB,SAAS,YAAY,UAAU,YAAY,UAAU,OAAO;AAAA,IACzF;AAGA,QAAI,MAAM,SAAS,eAAe,MAAM,SAAS,gBAAgB;AAC/D,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,QAAI,MAAM,SAAS,aAAa;AAC9B,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,QAAI,MAAM,SAAS,SAAS,MAAM,GAAG;AACnC,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,QACE,MAAM,SAAS,SAAS,aAAa,KACrC,MAAM,SAAS,SAAS,yBAAyB,GACjD;AACA,YAAM,IAAI;AAAA,QACR,MAAM;AAAA,QACN,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,UAAM,IAAI;AAAA,MACR,8BAA8B,MAAM,WAAW,wBAAwB;AAAA,MACvE,gBAAgB,aAAa;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,6BAA6B,cAA8B;AACjE,UAAM,QAAQ,aAAa,MAAM,6BAA6B;AAC9D,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI,gBAAgB,aAAa;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA,EAKQ,yBAAyB,QAAwB;AACvD,YAAQ,QAAQ;AAAA,MACd,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT;AACE,eAAO,QAAQ,MAAM;AAAA,IACzB;AAAA,EACF;AACF;AA/Ma;AAAb,IAAM,SAAN;AAiNA,IAAO,iBAAQ;;;ACnNf,IAAqB,UAArB,MAAqB,QAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAa1B,YACmB,UACA,YACA,WACA,aACA,aACjB;AALiB;AACA;AACA;AACA;AACA;AAjBnB,SAAiB,WAAW,gBAAgB;AAmB1C,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAEA,SAAK,aAAa,IAAI,oBAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,QAAQ,YAAmC;AAC/C,QAAI;AAEF,UAAI,CAAC,YAAY,KAAK,GAAG;AACvB,cAAM,IAAI,MAAM,4CAA4C;AAAA,MAC9D;AAGA,YAAM,MAAM,GAAG,KAAK,QAAQ,WAAW,KAAK,UAAU,IAAI,KAAK,SAAS,IAAI,KAAK,WAAW,cAAc,UAAU;AAGpH,YAAM,UAAU;AAAA,QACd,eAAe,UAAU,KAAK,WAAW;AAAA,QACzC,aAAa,KAAK;AAAA,QAClB,QAAQ;AAAA,QACR,gBAAgB;AAAA,MAClB;AAGA,YAAM,KAAK,WAAW,OAAO,KAAK,OAAO;AAAA,IAI3C,SAAS,OAAY;AAEnB,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,YAAY,OAAmB;AAErC,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAM,aAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAE7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAGA,QAAI,MAAM,UAAU;AAClB,YAAM,SAAS,KAAK,kBAAkB,KAAK;AAC3C,YAAM,eAAe,KAAK,yBAAyB,MAAM;AACzD,YAAM,IAAI,iBAAiB,cAAc,QAAQ,WAAW;AAAA,IAC9D;AAGA,QAAI,MAAM,SAAS,eAAe,MAAM,SAAS,gBAAgB;AAC/D,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,QAAI,MAAM,SAAS,eAAe,MAAM,SAAS,SAAS,SAAS,GAAG;AACpE,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,QAAI,MAAM,SAAS,SAAS,MAAM,GAAG;AACnC,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,QAAI,MAAM,SAAS,SAAS,UAAU,KAAK,MAAM,SAAS,SAAS,OAAO,GAAG;AAC3E,YAAM,IAAI;AAAA,QACR,qBAAqB,MAAM,OAAO;AAAA,QAClC,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,QAAI,iBAAiB,OAAO;AAC1B,YAAM,IAAI;AAAA,QACR,8BAA8B,MAAM,OAAO;AAAA,QAC3C,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,UAAM,IAAI;AAAA,MACR;AAAA,MACA,gBAAgB,aAAa;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkB,OAAoB;AAC5C,WACE,MAAM,UAAU,UAAU,MAAM,UAAU,gBAAgB,aAAa;AAAA,EAE3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,6BAA6B,cAA8B;AACjE,UAAM,QAAQ,aAAa,MAAM,6BAA6B;AAC9D,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI,gBAAgB,aAAa;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA,EAKQ,yBAAyB,QAAwB;AACvD,YAAQ,QAAQ;AAAA,MACd,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT;AACE,eAAO,QAAQ,MAAM;AAAA,IACzB;AAAA,EACF;AACF;AA3L4B;AAA5B,IAAqB,SAArB;;;ACOA,IAAM,mBAAN,MAAM,iBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAepB,YACmB,UACA,YACA,WACA,aACA,aACjB;AALiB;AACA;AACA;AACA;AACA;AAEjB,SAAK,cAAc,IAAI,aAAK,UAAU,YAAY,WAAW,aAAa,WAAW;AACrF,SAAK,aAAa,IAAI,YAAI,UAAU,YAAY,WAAW,aAAa,WAAW;AACnF,SAAK,gBAAgB,IAAI,eAAO,UAAU,YAAY,WAAW,aAAa,WAAW;AACzF,SAAK,gBAAgB,IAAI,OAAO,UAAU,YAAY,WAAW,aAAa,WAAW;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6BA,MAAM,KAAK,cAAwC,CAAC,GAAwB;AAC1E,QAAI;AACF,aAAO,MAAM,KAAK,YAAY,QAAQ,WAAW;AAAA,IACnD,SAAS,OAAO;AAEd,UAAI,iBAAiB,kBAAkB;AACrC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,uCAAuC,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QAC/F;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,MAAM,IAAI,YAAoB,cAAsC,CAAC,GAAsB;AACzF,QAAI;AACF,aAAO,MAAM,KAAK,WAAW,QAAQ,YAAY,WAAW;AAAA,IAC9D,SAAS,OAAO;AAEd,UAAI,iBAAiB,kBAAkB;AACrC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,sCAAsC,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QAC9F;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+BA,MAAM,OAAO,cAAqD;AAChE,QAAI;AACF,aAAO,MAAM,KAAK,cAAc,QAAQ,YAAY;AAAA,IACtD,SAAS,OAAO;AAEd,UAAI,iBAAiB,kBAAkB;AACrC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,yCAAyC,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACjG;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,MAAM,OAAO,YAAmC;AAC9C,QAAI;AACF,aAAO,MAAM,KAAK,cAAc,QAAQ,UAAU;AAAA,IACpD,SAAS,OAAO;AAEd,UAAI,iBAAiB,kBAAkB;AACrC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,yCAAyC,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACjG;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AArLsB;AAAtB,IAAM,kBAAN;AAuLA,IAAO,mBAAQ;;;AC7Lf,IAAqBC,SAArB,MAAqBA,OAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYxB,YACmB,UACA,YACA,WACA,aACA,aACjB;AALiB;AACA;AACA;AACA;AACA;AAEjB,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAEA,SAAK,aAAa,IAAI,oBAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,QAAQ,YAA8C;AAC1D,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,QAAI;AACF,YAAM,MAAM,GAAG,gBAAgB,QAAQ,WAAW,KAAK,UAAU,IAAI,KAAK,SAAS,IAAI,KAAK,WAAW,cAAc,UAAU;AAC/H,aAAO,MAAM,KAAK,cAAc,GAAG;AAAA,IACrC,SAAS,OAAY;AACnB,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAc,cACZ,KACA,qBAAsC,CAAC,GACb;AAC1B,UAAM,WAAW,MAAM,KAAK,WAAW,IAAI,KAAK;AAAA,MAC9C,eAAe,UAAU,KAAK,WAAW;AAAA,MACzC,aAAa,KAAK;AAAA,MAClB,QAAQ;AAAA,IACV,CAAC;AAGD,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC/C,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAEA,QAAI,OAAO,aAAa,UAAU;AAChC,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAEA,UAAM,OAAO;AAGb,QAAI,CAAC,KAAK,aAAa,CAAC,MAAM,QAAQ,KAAK,UAAU,aAAa,GAAG;AACnE,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAEA,UAAM,qBAAqB,KAAK,UAAU;AAG1C,UAAM,aAAa,CAAC,GAAG,oBAAoB,GAAG,kBAAkB;AAGhE,UAAM,cAAc,KAAK,QAAQ,MAAM;AAEvC,QAAI,aAAa;AAEf,aAAO,MAAM,KAAK,cAAc,aAAa,UAAU;AAAA,IACzD;AAGA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,YAAY,OAAmB;AAErC,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAMC,cAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAMC,gBAAe,KAAK,yBAAyBD,WAAU;AAE7D,YAAM,IAAI,iBAAiBC,eAAcD,WAAU;AAAA,IACrD;AAGA,QAAI,MAAM,UAAU;AAClB,YAAMA,cAAa,KAAK,kBAAkB,KAAK;AAC/C,YAAMC,gBACJ,MAAM,SAAS,MAAM,WAAW,KAAK,yBAAyBD,WAAU;AAE1E,YAAM,IAAI;AAAA,QACRC;AAAA,QACAD;AAAA,QACA,MAAM,SAAS;AAAA,QACf,MAAM,SAAS;AAAA,MACjB;AAAA,IACF;AAGA,QAAI;AACJ,QAAI;AAEJ,QAAI,iBAAiB,OAAO;AAC1B,UAAI,MAAM,QAAQ,SAAS,SAAS,KAAK,MAAM,QAAQ,SAAS,WAAW,GAAG;AAC5E,uBAAe;AACf,qBAAa,gBAAgB,aAAa;AAAA,MAC5C,WAAW,MAAM,QAAQ,SAAS,MAAM,KAAK,MAAM,QAAQ,SAAS,OAAO,GAAG;AAC5E,uBAAe;AACf,qBAAa,gBAAgB,aAAa;AAC1C,cAAM,IAAI,iBAAiB,cAAc,YAAY,aAAa;AAAA,MACpE,OAAO;AACL,uBAAe,kBAAkB,MAAM,OAAO;AAC9C,qBAAa,gBAAgB,aAAa;AAAA,MAC5C;AAAA,IACF,OAAO;AACL,qBAAe,mBAAmB,gBAAgB,aAAa,qBAAqB;AACpF,mBAAa,gBAAgB,aAAa;AAAA,IAC5C;AAEA,UAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,kBAAkB,OAAoB;AAC5C,WAAO,MAAM,UAAU,UAAU,gBAAgB,aAAa;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,6BAA6B,cAA8B;AACjE,UAAM,QAAQ,aAAa,MAAM,6BAA6B;AAC9D,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI,gBAAgB,aAAa;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,yBAAyB,YAA4B;AAC3D,YAAQ,YAAY;AAAA,MAClB,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT;AACE,eAAO,mCAAmC,UAAU;AAAA,IACxD;AAAA,EACF;AACF;AAhO0B,OAAAD,QAAA;AAA1B,IAAqBG,QAArBH;;;ACHA,IAAqBI,QAArB,MAAqBA,MAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYvB,YACmB,UACA,YACA,WACA,aACA,aACjB;AALiB;AACA;AACA;AACA;AACA;AAEjB,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAEA,SAAK,aAAa,IAAI,oBAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,QAAQ,YAAoB,WAA2C;AAC3E,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,QAAI;AACF,YAAM,MAAM,GAAG,gBAAgB,QAAQ,WAAW,KAAK,UAAU,IAAI,KAAK,SAAS,IAAI,KAAK,WAAW,cAAc,UAAU,kBAAkB,mBAAmB,SAAS,CAAC;AAE9K,YAAM,WAAW,MAAM,KAAK,WAAW,IAAI,KAAK;AAAA,QAC9C,eAAe,UAAU,KAAK,WAAW;AAAA,QACzC,aAAa,KAAK;AAAA,QAClB,QAAQ;AAAA,MACV,CAAC;AAGD,UAAI,aAAa,QAAQ,aAAa,QAAW;AAC/C,cAAM,IAAI;AAAA,UACR;AAAA,UACA,gBAAgB,aAAa;AAAA,UAC7B;AAAA,QACF;AAAA,MACF;AAEA,UAAI,OAAO,aAAa,UAAU;AAChC,cAAM,IAAI;AAAA,UACR;AAAA,UACA,gBAAgB,aAAa;AAAA,UAC7B;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT,SAAS,OAAY;AACnB,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,YAAY,OAAmB;AAErC,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAMC,cAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAMC,gBAAe,KAAK,yBAAyBD,WAAU;AAE7D,YAAM,IAAI,iBAAiBC,eAAcD,WAAU;AAAA,IACrD;AAGA,QAAI,MAAM,UAAU;AAClB,YAAMA,cAAa,KAAK,kBAAkB,KAAK;AAC/C,YAAMC,gBACJ,MAAM,SAAS,MAAM,WAAW,KAAK,yBAAyBD,WAAU;AAE1E,YAAM,IAAI;AAAA,QACRC;AAAA,QACAD;AAAA,QACA,MAAM,SAAS,MAAM;AAAA,QACrB,MAAM,SAAS,MAAM;AAAA,MACvB;AAAA,IACF;AAGA,QAAI;AACJ,QAAI;AAEJ,QAAI,iBAAiB,OAAO;AAC1B,UAAI,MAAM,QAAQ,SAAS,SAAS,KAAK,MAAM,QAAQ,SAAS,WAAW,GAAG;AAC5E,uBAAe;AACf,qBAAa,gBAAgB,aAAa;AAAA,MAC5C,WAAW,MAAM,QAAQ,SAAS,MAAM,KAAK,MAAM,QAAQ,SAAS,OAAO,GAAG;AAC5E,uBAAe;AACf,qBAAa,gBAAgB,aAAa;AAC1C,cAAM,IAAI,iBAAiB,cAAc,YAAY,aAAa;AAAA,MACpE,OAAO;AACL,uBAAe,kBAAkB,MAAM,OAAO;AAC9C,qBAAa,gBAAgB,aAAa;AAAA,MAC5C;AAAA,IACF,OAAO;AACL,qBAAe,mBAAmB,gBAAgB,aAAa,qBAAqB;AACpF,mBAAa,gBAAgB,aAAa;AAAA,IAC5C;AAEA,UAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,kBAAkB,OAAoB;AAC5C,WAAO,MAAM,UAAU,UAAU,gBAAgB,aAAa;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,6BAA6B,cAA8B;AACjE,UAAM,QAAQ,aAAa,MAAM,6BAA6B;AAC9D,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI,gBAAgB,aAAa;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,yBAAyB,YAA4B;AAC3D,YAAQ,YAAY;AAAA,MAClB,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT;AACE,eAAO,mCAAmC,UAAU;AAAA,IACxD;AAAA,EACF;AACF;AA9LyB,OAAAD,OAAA;AAAzB,IAAqBG,OAArBH;;;ACKA,IAAMI,WAAN,MAAMA,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaX,YACmB,UACA,YACA,WACA,aACA,aACjB;AALiB;AACA;AACA;AACA;AACA;AAjBnB,SAAiB,WAAmB,gBAAgB;AAmBlD,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAEA,SAAK,aAAa,IAAI,oBAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,QACJ,YACA,mBACwB;AACxB,QAAI;AAEF,UAAI,CAAC,YAAY,KAAK,GAAG;AACvB,cAAM,IAAI;AAAA,UACR;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,UAAI,CAAC,mBAAmB;AACtB,cAAM,IAAI,iBAAiB,iCAAiC,KAAK,kBAAkB;AAAA,MACrF;AAGA,WAAK,2BAA2B,iBAAiB;AAGjD,YAAM,aAAa,KAAK,oBAAoB,iBAAiB;AAG7D,YAAM,MAAM,GAAG,KAAK,QAAQ,WAAW,KAAK,UAAU,IAAI,KAAK,SAAS,IAAI,KAAK,WAAW,cAAc,UAAU;AAGpH,YAAM,UAAU;AAAA,QACd,eAAe,UAAU,KAAK,WAAW;AAAA,QACzC,aAAa,KAAK;AAAA,QAClB,QAAQ;AAAA,QACR,gBAAgB;AAAA,MAClB;AAGA,YAAM,WAA0B,MAAM,KAAK,WAAW,KAAK,KAAK,SAAS,UAAU;AAGnF,UAAI,aAAa,QAAQ,aAAa,QAAW;AAC/C,cAAM,IAAI;AAAA,UACR;AAAA,UACA,gBAAgB,aAAa;AAAA,QAC/B;AAAA,MACF;AAEA,UAAI,OAAO,aAAa,UAAU;AAChC,cAAM,IAAI;AAAA,UACR;AAAA,UACA,gBAAgB,aAAa;AAAA,QAC/B;AAAA,MACF;AAEA,aAAO;AAAA,IACT,SAAS,OAAY;AAEnB,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,2BAA2B,mBAAkD;AACnF,UAAM,EAAE,aAAa,OAAO,YAAY,sBAAsB,IAAI;AAGlE,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,OAAO,KAAK,GAAG;AAClB,YAAM,IAAI,iBAAiB,yCAAyC,KAAK,kBAAkB;AAAA,IAC7F;AAEA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAGA,QAAI,YAAY,SAAS,KAAK;AAC5B,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AAEA,QAAI,MAAM,SAAS,KAAK;AACtB,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACtD;AAEA,QAAI,WAAW,SAAS,KAAK;AAC3B,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC3D;AAGA,UAAM,qBAAqB;AAC3B,QAAI,CAAC,mBAAmB,KAAK,WAAW,GAAG;AACzC,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC3D;AAEA,UAAM,eAAe;AACrB,QAAI,CAAC,aAAa,KAAK,KAAK,GAAG;AAC7B,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD;AAEA,UAAM,mBAAmB;AACzB,QAAI,CAAC,iBAAiB,KAAK,UAAU,GAAG;AACtC,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC1D;AAGA,QAAI,0BAA0B,QAAW;AACvC,UAAI,OAAO,0BAA0B,YAAY,0BAA0B,MAAM;AAC/E,cAAM,IAAI,MAAM,mDAAmD;AAAA,MACrE;AAEA,UAAI;AAGF,cAAM,aAAa,KAAK,UAAU,qBAAqB;AACvD,cAAM,eAAe,OAAO,KAAK,UAAU,EAAE,SAAS,QAAQ,EAAE;AAEhE,YAAI,eAAe,OAAO;AACxB,gBAAM,IAAI,MAAM,oEAAoE;AAAA,QACtF;AAAA,MACF,SAAS,OAAO;AACd,YACE,iBAAiB,SACjB,MAAM,QAAQ,SAAS,gDAAgD,GACvE;AACA,gBAAM;AAAA,QACR;AACA,cAAM,IAAI,MAAM,mDAAmD;AAAA,MACrE;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,oBAAoB,mBAAiD;AAC3E,UAAM,EAAE,uBAAuB,GAAG,KAAK,IAAI;AAE3C,UAAM,UAAe,EAAE,GAAG,KAAK;AAG/B,QAAI,0BAA0B,QAAW;AACvC,cAAQ,wBAAwB,OAAO,KAAK,KAAK,UAAU,qBAAqB,CAAC,EAAE;AAAA,QACjF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,YAAY,OAAmB;AAErC,QAAI,iBAAiB,kBAAkB;AACrC,YAAM;AAAA,IACR;AAGA,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAMC,cAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAMC,gBAAe,KAAK,yBAAyBD,WAAU;AAE7D,YAAM,IAAI,iBAAiBC,eAAcD,WAAU;AAAA,IACrD;AAGA,QAAI,MAAM,UAAU;AAClB,YAAMA,cAAa,KAAK,kBAAkB,KAAK;AAC/C,YAAMC,gBACJ,MAAM,SAAS,MAAM,WAAW,KAAK,yBAAyBD,WAAU;AAE1E,YAAM,IAAI;AAAA,QACRC;AAAA,QACAD;AAAA,QACA,MAAM,SAAS,MAAM;AAAA,QACrB,MAAM,SAAS,MAAM;AAAA,MACvB;AAAA,IACF;AAGA,QAAI;AACJ,QAAI;AAEJ,QAAI,iBAAiB,OAAO;AAC1B,UAAI,MAAM,QAAQ,SAAS,SAAS,KAAK,MAAM,QAAQ,SAAS,WAAW,GAAG;AAC5E,uBAAe;AACf,qBAAa,gBAAgB,aAAa;AAAA,MAC5C,WACE,MAAM,QAAQ,SAAS,aAAa,KACpC,MAAM,QAAQ,SAAS,iBAAiB,KACxC,MAAM,QAAQ,SAAS,eAAe,KACtC,MAAM,QAAQ,SAAS,6BAA6B,KACpD,MAAM,QAAQ,SAAS,iBAAiB,KACxC,MAAM,QAAQ,SAAS,+BAA+B,GACtD;AAEA,cAAM,IAAI;AAAA,UACR,MAAM;AAAA,UACN,gBAAgB,aAAa;AAAA,UAC7B;AAAA,QACF;AAAA,MACF,WAAW,MAAM,QAAQ,SAAS,MAAM,KAAK,MAAM,QAAQ,SAAS,OAAO,GAAG;AAC5E,uBAAe;AACf,qBAAa,gBAAgB,aAAa;AAAA,MAC5C,OAAO;AACL,uBAAe,kBAAkB,MAAM,OAAO;AAC9C,qBAAa,gBAAgB,aAAa;AAAA,MAC5C;AAAA,IACF,OAAO;AACL,qBAAe,mBAAmB,gBAAgB,aAAa,qBAAqB;AACpF,mBAAa,gBAAgB,aAAa;AAAA,IAC5C;AAEA,UAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,kBAAkB,OAAoB;AAC5C,WAAO,MAAM,UAAU,UAAU,gBAAgB,aAAa;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,6BAA6B,cAA8B;AACjE,UAAM,QAAQ,aAAa,MAAM,6BAA6B;AAC9D,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI,gBAAgB,aAAa;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,yBAAyB,YAA4B;AAC3D,YAAQ,YAAY;AAAA,MAClB,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT;AACE,eAAO,mCAAmC,UAAU;AAAA,IACxD;AAAA,EACF;AACF;AA9Ua,OAAAD,UAAA;AAAb,IAAMG,UAANH;AAgVA,IAAOI,kBAAQD;;;ACnVf,IAAME,WAAN,MAAMA,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaX,YACmB,UACA,YACA,WACA,aACA,aACjB;AALiB;AACA;AACA;AACA;AACA;AAjBnB,SAAiB,WAAmB,gBAAgB;AAmBlD,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC/D;AAEA,SAAK,aAAa,IAAI,oBAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,QAAQ,YAAoB,WAAmC;AACnE,QAAI;AAEF,UAAI,CAAC,YAAY,KAAK,GAAG;AACvB,cAAM,IAAI;AAAA,UACR;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,UAAI,cAAc,UAAa,CAAC,WAAW,KAAK,GAAG;AACjD,cAAM,IAAI;AAAA,UACR;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,UAAI,MAAM,GAAG,KAAK,QAAQ,WAAW,KAAK,UAAU,IAAI,KAAK,SAAS,IAAI,KAAK,WAAW,cAAc,UAAU;AAClH,UAAI,WAAW,KAAK,GAAG;AACrB,eAAO,IAAI,mBAAmB,UAAU,KAAK,CAAC,CAAC;AAAA,MACjD;AAGA,YAAM,UAAU;AAAA,QACd,eAAe,UAAU,KAAK,WAAW;AAAA,QACzC,aAAa,KAAK;AAAA,QAClB,QAAQ;AAAA,MACV;AAGA,YAAM,KAAK,WAAW,OAAO,KAAK,OAAO;AAAA,IAG3C,SAAS,OAAY;AAEnB,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,YAAY,OAAmB;AAErC,QAAI,iBAAiB,kBAAkB;AACrC,YAAM;AAAA,IACR;AAGA,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAMC,cAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAMC,gBAAe,KAAK,yBAAyBD,WAAU;AAE7D,YAAM,IAAI,iBAAiBC,eAAcD,WAAU;AAAA,IACrD;AAGA,QAAI,MAAM,UAAU;AAClB,YAAMA,cAAa,KAAK,kBAAkB,KAAK;AAC/C,YAAMC,gBACJ,MAAM,SAAS,MAAM,WAAW,KAAK,yBAAyBD,WAAU;AAE1E,YAAM,IAAI;AAAA,QACRC;AAAA,QACAD;AAAA,QACA,MAAM,SAAS,MAAM;AAAA,QACrB,MAAM,SAAS,MAAM;AAAA,MACvB;AAAA,IACF;AAGA,QAAI;AACJ,QAAI;AAEJ,QAAI,iBAAiB,OAAO;AAC1B,UAAI,MAAM,QAAQ,SAAS,SAAS,KAAK,MAAM,QAAQ,SAAS,WAAW,GAAG;AAC5E,uBAAe;AACf,qBAAa,gBAAgB,aAAa;AAAA,MAC5C,WACE,MAAM,QAAQ,SAAS,aAAa,KACpC,MAAM,QAAQ,SAAS,iBAAiB,GACxC;AAEA,cAAM,IAAI;AAAA,UACR,MAAM;AAAA,UACN,gBAAgB,aAAa;AAAA,UAC7B;AAAA,QACF;AAAA,MACF,WAAW,MAAM,QAAQ,SAAS,MAAM,KAAK,MAAM,QAAQ,SAAS,OAAO,GAAG;AAC5E,uBAAe;AACf,qBAAa,gBAAgB,aAAa;AAAA,MAC5C,OAAO;AACL,uBAAe,kBAAkB,MAAM,OAAO;AAC9C,qBAAa,gBAAgB,aAAa;AAAA,MAC5C;AAAA,IACF,OAAO;AACL,qBAAe,mBAAmB,gBAAgB,aAAa,qBAAqB;AACpF,mBAAa,gBAAgB,aAAa;AAAA,IAC5C;AAEA,UAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,kBAAkB,OAAoB;AAC5C,WAAO,MAAM,UAAU,UAAU,gBAAgB,aAAa;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,6BAA6B,cAA8B;AACjE,UAAM,QAAQ,aAAa,MAAM,6BAA6B;AAC9D,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI,gBAAgB,aAAa;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,yBAAyB,YAA4B;AAC3D,YAAQ,YAAY;AAAA,MAClB,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT;AACE,eAAO,mCAAmC,UAAU;AAAA,IACxD;AAAA,EACF;AACF;AA1Ma,OAAAD,UAAA;AAAb,IAAMG,UAANH;AA4MA,IAAO,iBAAQG;;;ACvMf,IAAM,wBAAN,MAAM,sBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAezB,YACmB,UACA,YACA,WACA,aACA,aACjB;AALiB;AACA;AACA;AACA;AACA;AAEjB,SAAK,cAAc,IAAIC,MAAK,UAAU,YAAY,WAAW,aAAa,WAAW;AACrF,SAAK,aAAa,IAAIC,KAAI,UAAU,YAAY,WAAW,aAAa,WAAW;AACnF,SAAK,gBAAgB,IAAIC,gBAAO,UAAU,YAAY,WAAW,aAAa,WAAW;AACzF,SAAK,gBAAgB,IAAI,eAAO,UAAU,YAAY,WAAW,aAAa,WAAW;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAM,KAAK,YAA8C;AACvD,QAAI;AACF,aAAO,MAAM,KAAK,YAAY,QAAQ,UAAU;AAAA,IAClD,SAAS,OAAO;AACd,UAAI,iBAAiB,kBAAkB;AACrC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,4CAA4C,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACpG;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAM,IAAI,YAAoB,WAA2C;AACvE,QAAI;AACF,aAAO,MAAM,KAAK,WAAW,QAAQ,YAAY,SAAS;AAAA,IAC5D,SAAS,OAAO;AACd,UAAI,iBAAiB,kBAAkB;AACrC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,2CAA2C,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACnG;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBA,MAAM,OACJ,YACA,mBACwB;AACxB,QAAI;AACF,aAAO,MAAM,KAAK,cAAc,QAAQ,YAAY,iBAAiB;AAAA,IACvE,SAAS,OAAO;AACd,UAAI,iBAAiB,kBAAkB;AACrC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,8CAA8C,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACtG;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,MAAM,OAAO,YAAoB,WAAmC;AAClE,QAAI;AACF,aAAO,MAAM,KAAK,cAAc,QAAQ,YAAY,SAAS;AAAA,IAC/D,SAAS,OAAO;AACd,UAAI,iBAAiB,kBAAkB;AACrC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,8CAA8C,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACtG;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAlJ2B;AAA3B,IAAM,uBAAN;AAoJA,IAAO,yBAAQ;;;AC1JR,IAAMC,WAAN,MAAMA,SAAO;AAAA;AAAA;AAAA;AAAA,EAWlB,YACE,UACA,YACA,WACA,aACA,aACA;AACA,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,iBAAiB,4CAA4C,GAAG;AAAA,IAC5E;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,iBAAiB,8CAA8C,GAAG;AAAA,IAC9E;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,iBAAiB,6CAA6C,GAAG;AAAA,IAC7E;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,iBAAiB,+CAA+C,GAAG;AAAA,IAC/E;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,iBAAiB,+CAA+C,GAAG;AAAA,IAC/E;AAEA,SAAK,aAAa,IAAI,oBAAW;AACjC,SAAK,WAAW,gBAAgB;AAChC,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,cAAc;AACnB,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4BA,MAAM,QAAQ,kBAAkE;AAC9E,QAAI;AACF,WAAK,0BAA0B,gBAAgB;AAE/C,YAAM,MAAM,GAAG,KAAK,QAAQ,WAAW,KAAK,UAAU,IAAI,KAAK,SAAS,IAAI,KAAK,WAAW;AAE5F,YAAM,WAAW,MAAM,KAAK,WAAW;AAAA,QACrC;AAAA,QACA;AAAA,UACE,eAAe,UAAU,KAAK,WAAW;AAAA,UACzC,aAAa,KAAK;AAAA,UAClB,gBAAgB;AAAA,UAChB,QAAQ;AAAA,QACV;AAAA,QACA;AAAA,MACF;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,0BAA0B,kBAAiD;AACjF,QAAI,CAAC,kBAAkB;AACrB,YAAM,IAAI,iBAAiB,iCAAiC,GAAG;AAAA,IACjE;AAEA,QAAI,CAAC,iBAAiB,WAAW,KAAK,GAAG;AACvC,YAAM,IAAI,iBAAiB,yBAAyB,GAAG;AAAA,IACzD;AAEA,QAAI,iBAAiB,UAAU,SAAS,KAAK,iBAAiB,UAAU,SAAS,KAAK;AACpF,YAAM,IAAI,iBAAiB,kDAAkD,GAAG;AAAA,IAClF;AAEA,QAAI,CAAC,iBAAiB,MAAM,KAAK,GAAG;AAClC,YAAM,IAAI,iBAAiB,iCAAiC,GAAG;AAAA,IACjE;AAEA,QAAI,iBAAiB,KAAK,SAAS,KAAK,iBAAiB,KAAK,SAAS,KAAK;AAC1E,YAAM,IAAI,iBAAiB,0DAA0D,GAAG;AAAA,IAC1F;AAEA,QAAI,iBAAiB,eAAe,iBAAiB,YAAY,SAAS,KAAM;AAC9E,YAAM,IAAI,iBAAiB,+CAA+C,GAAG;AAAA,IAC/E;AAEA,QAAI,iBAAiB,eAAe,iBAAiB,YAAY,SAAS,KAAM;AAC9E,YAAM,IAAI,iBAAiB,+CAA+C,GAAG;AAAA,IAC/E;AAEA,QACE,CAAC,iBAAiB,sBAClB,CAAC,MAAM,QAAQ,iBAAiB,kBAAkB,GAClD;AACA,YAAM,IAAI,iBAAiB,uDAAuD,GAAG;AAAA,IACvF;AAEA,QAAI,iBAAiB,mBAAmB,WAAW,GAAG;AACpD,YAAM,IAAI,iBAAiB,8CAA8C,GAAG;AAAA,IAC9E;AAGA,qBAAiB,mBAAmB,QAAQ,CAAC,OAAO,UAAU;AAC5D,UAAI,CAAC,MAAM,aAAa,KAAK,GAAG;AAC9B,cAAM,IAAI,iBAAiB,8CAA8C,KAAK,IAAI,GAAG;AAAA,MACvF;AACA,UAAI,CAAC,MAAM,YAAY,KAAK,GAAG;AAC7B,cAAM,IAAI,iBAAiB,6CAA6C,KAAK,IAAI,GAAG;AAAA,MACtF;AAAA,IACF,CAAC;AAED,QAAI,CAAC,iBAAiB,eAAe,KAAK,GAAG;AAC3C,YAAM,IAAI,iBAAiB,6BAA6B,GAAG;AAAA,IAC7D;AAEA,UAAM,qBAAqB,CAAC,WAAW,iBAAiB,WAAW,iBAAiB;AACpF,QAAI,CAAC,mBAAmB,SAAS,iBAAiB,aAAa,GAAG;AAChE,YAAM,IAAI;AAAA,QACR,iCAAiC,mBAAmB,KAAK,IAAI,CAAC;AAAA,QAC9D;AAAA,MACF;AAAA,IACF;AAEA,QAAI,iBAAiB,kBAAkB,iBAAiB,eAAe,SAAS,KAAK;AACnF,YAAM,IAAI,iBAAiB,iDAAiD,GAAG;AAAA,IACjF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY,OAAmB;AAErC,QAAI,iBAAiB,kBAAkB;AACrC,YAAM;AAAA,IACR;AAEA,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAM,aAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAEA,QAAI,MAAM,UAAU,QAAQ;AAC1B,YAAM,aAAa,MAAM,SAAS;AAClC,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAEA,QAAI,MAAM,QAAQ;AAChB,YAAM,aAAa,MAAM;AACzB,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAEA,UAAM,IAAI,iBAAiB,0BAA0B,GAAG;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKQ,6BAA6B,SAAyB;AAC5D,UAAM,QAAQ,QAAQ,MAAM,6BAA6B;AACzD,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKQ,yBAAyB,YAA4B;AAC3D,YAAQ,YAAY;AAAA,MAClB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO,mBAAmB,UAAU;AAAA,IACxC;AAAA,EACF;AACF;AA5NoB,OAAAA,UAAA;AAAb,IAAMC,UAAND;AA8NP,IAAOE,kBAAQD;;;AChOR,IAAME,WAAN,MAAMA,SAAO;AAAA;AAAA;AAAA;AAAA,EAWlB,YACE,UACA,YACA,WACA,aACA,aACA;AACA,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,iBAAiB,4CAA4C,GAAG;AAAA,IAC5E;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,iBAAiB,8CAA8C,GAAG;AAAA,IAC9E;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,iBAAiB,6CAA6C,GAAG;AAAA,IAC7E;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,iBAAiB,+CAA+C,GAAG;AAAA,IAC/E;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,iBAAiB,+CAA+C,GAAG;AAAA,IAC/E;AAEA,SAAK,aAAa,IAAI,oBAAW;AACjC,SAAK,WAAW,gBAAgB;AAChC,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,cAAc;AACnB,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,MAAM,QAAQ,gBAAuC;AACnD,QAAI;AACF,WAAK,eAAe,cAAc;AAElC,YAAM,MAAM,GAAG,KAAK,QAAQ,WAAW,KAAK,UAAU,IAAI,KAAK,SAAS,IAAI,KAAK,WAAW,kBAAkB,cAAc;AAE5H,YAAM,KAAK,WAAW,OAAO,KAAK;AAAA,QAChC,eAAe,UAAU,KAAK,WAAW;AAAA,QACzC,aAAa,KAAK;AAAA,QAClB,QAAQ;AAAA,MACV,CAAC;AAAA,IAGH,SAAS,OAAO;AACd,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,gBAA8B;AACnD,QAAI,CAAC,gBAAgB,KAAK,GAAG;AAC3B,YAAM,IAAI,iBAAiB,+BAA+B,GAAG;AAAA,IAC/D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY,OAAmB;AACrC,QAAI,iBAAiB,kBAAkB;AACrC,YAAM;AAAA,IACR;AAEA,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAM,aAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAEA,QAAI,MAAM,UAAU,QAAQ;AAC1B,YAAM,aAAa,MAAM,SAAS;AAClC,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAEA,QAAI,MAAM,QAAQ;AAChB,YAAM,aAAa,MAAM;AACzB,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAEA,UAAM,IAAI,iBAAiB,0BAA0B,GAAG;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKQ,6BAA6B,SAAyB;AAC5D,UAAM,QAAQ,QAAQ,MAAM,6BAA6B;AACzD,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKQ,yBAAyB,YAA4B;AAC3D,YAAQ,YAAY;AAAA,MAClB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO,mBAAmB,UAAU;AAAA,IACxC;AAAA,EACF;AACF;AA1IoB,OAAAA,UAAA;AAAb,IAAMC,UAAND;AA4IP,IAAOE,kBAAQD;;;AC3IR,IAAME,QAAN,MAAMA,MAAI;AAAA;AAAA;AAAA;AAAA,EAWf,YACE,UACA,YACA,WACA,aACA,aACA;AACA,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,iBAAiB,4CAA4C,GAAG;AAAA,IAC5E;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,iBAAiB,8CAA8C,GAAG;AAAA,IAC9E;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,iBAAiB,6CAA6C,GAAG;AAAA,IAC7E;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,iBAAiB,+CAA+C,GAAG;AAAA,IAC/E;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,iBAAiB,+CAA+C,GAAG;AAAA,IAC/E;AAEA,SAAK,aAAa,IAAI,oBAAW;AACjC,SAAK,WAAW,gBAAgB;AAChC,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,cAAc;AACnB,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,MAAM,QAAQ,gBAA+C;AAC3D,QAAI;AACF,WAAK,eAAe,cAAc;AAElC,YAAM,MAAM,GAAG,KAAK,QAAQ,WAAW,KAAK,UAAU,IAAI,KAAK,SAAS,IAAI,KAAK,WAAW,kBAAkB,cAAc;AAE5H,YAAM,WAAW,MAAM,KAAK,WAAW,IAAI,KAAK;AAAA,QAC9C,eAAe,UAAU,KAAK,WAAW;AAAA,QACzC,aAAa,KAAK;AAAA,QAClB,QAAQ;AAAA,MACV,CAAC;AAED,aAAO;AAAA,IACT,SAAS,OAAO;AACd,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,gBAA8B;AACnD,QAAI,CAAC,gBAAgB,KAAK,GAAG;AAC3B,YAAM,IAAI,iBAAiB,+BAA+B,GAAG;AAAA,IAC/D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY,OAAmB;AACrC,QAAI,iBAAiB,kBAAkB;AACrC,YAAM;AAAA,IACR;AAEA,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAM,aAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAEA,QAAI,MAAM,UAAU,QAAQ;AAC1B,YAAM,aAAa,MAAM,SAAS;AAClC,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAEA,QAAI,MAAM,QAAQ;AAChB,YAAM,aAAa,MAAM;AACzB,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAEA,UAAM,IAAI,iBAAiB,0BAA0B,GAAG;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKQ,6BAA6B,SAAyB;AAC5D,UAAM,QAAQ,QAAQ,MAAM,6BAA6B;AACzD,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKQ,yBAAyB,YAA4B;AAC3D,YAAQ,YAAY;AAAA,MAClB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO,mBAAmB,UAAU;AAAA,IACxC;AAAA,EACF;AACF;AA1IiB,OAAAA,OAAA;AAAV,IAAMC,OAAND;AA4IP,IAAOE,eAAQD;;;AC3IR,IAAME,SAAN,MAAMA,OAAK;AAAA;AAAA;AAAA;AAAA,EAWhB,YACE,UACA,YACA,WACA,aACA,aACA;AACA,QAAI,CAAC,UAAU,KAAK,GAAG;AACrB,YAAM,IAAI,iBAAiB,4CAA4C,GAAG;AAAA,IAC5E;AACA,QAAI,CAAC,YAAY,KAAK,GAAG;AACvB,YAAM,IAAI,iBAAiB,8CAA8C,GAAG;AAAA,IAC9E;AACA,QAAI,CAAC,WAAW,KAAK,GAAG;AACtB,YAAM,IAAI,iBAAiB,6CAA6C,GAAG;AAAA,IAC7E;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,iBAAiB,+CAA+C,GAAG;AAAA,IAC/E;AACA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,iBAAiB,+CAA+C,GAAG;AAAA,IAC/E;AAEA,SAAK,aAAa,IAAI,oBAAW;AACjC,SAAK,WAAW,gBAAgB;AAChC,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,cAAc;AACnB,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,aAAoE;AAChF,QAAI;AACF,WAAK,eAAe;AAEpB,UAAI,MAAM,GAAG,KAAK,QAAQ,WAAW,KAAK,UAAU,IAAI,KAAK,SAAS,IAAI,KAAK,WAAW;AAG1F,UAAI,eAAe,OAAO,KAAK,WAAW,EAAE,SAAS,GAAG;AACtD,cAAM,eAAe,IAAI,gBAAgB;AACzC,eAAO,QAAQ,WAAW,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,cAAI,UAAU,UAAa,UAAU,MAAM;AACzC,yBAAa,OAAO,KAAK,OAAO,KAAK,CAAC;AAAA,UACxC;AAAA,QACF,CAAC;AACD,YAAI,aAAa,SAAS,GAAG;AAC3B,iBAAO,IAAI,aAAa,SAAS,CAAC;AAAA,QACpC;AAAA,MACF;AAEA,aAAO,MAAM,KAAK,cAAc,GAAG;AAAA,IACrC,SAAS,OAAY;AACnB,WAAK,YAAY,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,cACZ,KACA,qBAAqC,CAAC,GACb;AACzB,UAAM,UAAU;AAAA,MACd,eAAe,UAAU,KAAK,WAAW;AAAA,MACzC,aAAa,KAAK;AAAA,MAClB,gBAAgB;AAAA,IAClB;AAEA,UAAM,OAAQ,MAAM,KAAK,WAAW,IAAI,KAAK,OAAO;AAGpD,UAAM,2BAA2B,KAAK,WAAW,iBAAiB,CAAC;AACnE,UAAM,aAAa,CAAC,GAAG,oBAAoB,GAAG,wBAAwB;AAGtE,UAAM,cAAc,KAAK,QAAQ,MAAM;AACvC,QAAI,aAAa;AAEf,aAAO,MAAM,KAAK,cAAc,aAAa,UAAU;AAAA,IACzD;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,iBAAuB;AAC7B,QAAI,CAAC,KAAK,YAAY,KAAK,GAAG;AAC5B,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,MAC/B;AAAA,IACF;AACA,QAAI,CAAC,KAAK,WAAW,KAAK,GAAG;AAC3B,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,MAC/B;AAAA,IACF;AACA,QAAI,CAAC,KAAK,aAAa,KAAK,GAAG;AAC7B,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,MAC/B;AAAA,IACF;AACA,QAAI,CAAC,KAAK,aAAa,KAAK,GAAG;AAC7B,YAAM,IAAI;AAAA,QACR;AAAA,QACA,gBAAgB,aAAa;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY,OAAmB;AAErC,QAAI,iBAAiB,SAAS,MAAM,QAAQ,SAAS,qBAAqB,GAAG;AAC3E,YAAM,aAAa,KAAK,6BAA6B,MAAM,OAAO;AAClE,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAGA,QAAI,MAAM,UAAU;AAClB,YAAM,aACJ,MAAM,SAAS,UAAU,MAAM,UAAU,gBAAgB,aAAa;AACxE,YAAM,eAAe,KAAK,yBAAyB,UAAU;AAC7D,YAAM,IAAI,iBAAiB,cAAc,UAAU;AAAA,IACrD;AAGA,QAAI,iBAAiB,kBAAkB;AACrC,YAAM;AAAA,IACR;AAGA,UAAM,IAAI;AAAA,MACR,MAAM,WAAW;AAAA,MACjB,gBAAgB,aAAa;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,6BAA6B,cAA8B;AACjE,UAAM,QAAQ,aAAa,MAAM,6BAA6B;AAC9D,WAAO,QAAQ,SAAS,MAAM,CAAC,GAAI,EAAE,IAAI,gBAAgB,aAAa;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA,EAKQ,yBAAyB,YAA4B;AAC3D,YAAQ,YAAY;AAAA,MAClB,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT,KAAK,gBAAgB,aAAa;AAChC,eAAO;AAAA,MACT;AACE,eAAO,kCAAkC,UAAU;AAAA,IACvD;AAAA,EACF;AACF;AA3LkB,OAAAA,QAAA;AAAX,IAAMC,QAAND;AA6LP,IAAOE,gBAAQD;;;AC1LR,IAAM,uBAAN,MAAM,qBAAoB;AAAA;AAAA;AAAA;AAAA,EAS/B,YACE,UACA,YACA,WACA,aACA,aACA;AACA,SAAK,gBAAgB,IAAIE,gBAAO,UAAU,YAAY,WAAW,aAAa,WAAW;AACzF,SAAK,gBAAgB,IAAIC,gBAAO,UAAU,YAAY,WAAW,aAAa,WAAW;AACzF,SAAK,aAAa,IAAIC,aAAI,UAAU,YAAY,WAAW,aAAa,WAAW;AACnF,SAAK,cAAc,IAAIC,cAAK,UAAU,YAAY,WAAW,aAAa,WAAW;AAAA,EACvF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA2BA,MAAM,OAAO,kBAAkE;AAC7E,WAAO,MAAM,KAAK,cAAc,QAAQ,gBAAgB;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAM,OAAO,gBAAuC;AAClD,WAAO,MAAM,KAAK,cAAc,QAAQ,cAAc;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAM,IAAI,gBAA+C;AACvD,WAAO,MAAM,KAAK,WAAW,QAAQ,cAAc;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBA,MAAM,KAAK,aAAoE;AAC7E,WAAO,MAAM,KAAK,YAAY,QAAQ,WAAW;AAAA,EACnD;AACF;AAvGiC;AAA1B,IAAM,sBAAN;AAyGP,IAAO,uBAAQ;","names":["response_default","HttpStatus","HttpMethod","errorMessage","import_aio_sdk","context","WebhookOperation","response_default","SignatureVerification","response_default","openwhisk","import_aio_sdk","fetch","import_aio_sdk","got","_List","statusCode","errorMessage","List","_Get","statusCode","errorMessage","Get","_Create","statusCode","errorMessage","Create","create_default","_Delete","statusCode","errorMessage","Delete","List","Get","create_default","_Create","Create","create_default","_Delete","Delete","delete_default","_Get","Get","get_default","_List","List","list_default","create_default","delete_default","get_default","list_default"]}
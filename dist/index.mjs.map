{"version":3,"sources":["../src/framework/runtime-action/index.ts","../src/framework/runtime-action/types.ts","../src/framework/runtime-action/response/index.ts","../src/framework/utils/parameters/index.ts","../src/framework/utils/validator/index.ts"],"sourcesContent":["/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport { Core } from '@adobe/aio-sdk';\n\nimport RuntimeActionResponse from './response';\nimport Parameters from '../utils/parameters';\nimport Validator from '../utils/validator';\n\nimport { HttpStatus, HttpMethod } from './types';\nimport { ActionResponseType } from './response/types';\n\nclass RuntimeAction {\n  /**\n   * @param name\n   * @param httpMethods\n   * @param requiredParams\n   * @param requiredHeaders\n   * @param action\n   * @returns {(function(*): Promise<any>)|*}\n   */\n  static execute(\n    name: string = 'main',\n    httpMethods: HttpMethod[] = [],\n    requiredParams: string[] = [],\n    requiredHeaders: string[] = [],\n    action: (\n      params: { [key: string]: any },\n      ctx: { logger: any; headers: { [key: string]: any } }\n    ) => Promise<ActionResponseType> = async (_params): Promise<ActionResponseType> => {\n      return { statusCode: HttpStatus.OK, body: {} };\n    }\n  ): (params: { [key: string]: any }) => Promise<ActionResponseType> {\n    return async (params: { [key: string]: any }) => {\n      // create a Logger\n      const logger = Core.Logger(name, { level: params.LOG_LEVEL || 'info' });\n\n      try {\n        // 'info' is the default level if not set\n        logger.info(`Calling the ${name} action`);\n\n        // log parameters, only if params.LOG_LEVEL === 'debug'\n        logger.debug(Parameters.stringify(params));\n\n        // validate request\n        const validationError = RuntimeAction.validateRequest(\n          params,\n          requiredParams,\n          requiredHeaders,\n          httpMethods,\n          logger\n        );\n        if (validationError) {\n          return validationError;\n        }\n\n        const result = await action(params, { logger: logger, headers: params.__ow_headers || {} });\n        // log the error\n        logger.info(result);\n        return result;\n      } catch (error) {\n        // log any server errors\n        logger.error(error);\n        // return with 500\n        return RuntimeActionResponse.error(HttpStatus.INTERNAL_ERROR, 'server error');\n      }\n    };\n  }\n\n  private static validateRequest(\n    params: { [key: string]: any },\n    requiredParams: string[],\n    requiredHeaders: string[],\n    httpMethods: HttpMethod[],\n    logger: any\n  ): ActionResponseType | null {\n    // check for missing request input parameters and headers\n    const errorMessage =\n      Validator.checkMissingRequestInputs(params, requiredParams, requiredHeaders) ?? '';\n    if (errorMessage) {\n      // return and log client errors\n      return RuntimeActionResponse.error(HttpStatus.BAD_REQUEST, errorMessage);\n    }\n\n    // validate HTTP method\n    const requestMethod = params.__ow_method;\n    if (httpMethods.length > 0 && !httpMethods.includes(requestMethod)) {\n      const errorMessage = `Invalid HTTP method: ${requestMethod}. Allowed methods are: ${httpMethods.join(', ')}`;\n      logger.error(errorMessage);\n      return RuntimeActionResponse.error(HttpStatus.METHOD_NOT_ALLOWED, errorMessage);\n    }\n\n    return null;\n  }\n}\n\nexport default RuntimeAction;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nexport enum HttpStatus {\n  OK = 200,\n  BAD_REQUEST = 400,\n  UNAUTHORIZED = 401,\n  NOT_FOUND = 404,\n  METHOD_NOT_ALLOWED = 405,\n  INTERNAL_ERROR = 500,\n}\n\nexport enum HttpMethod {\n  GET = 'get',\n  POST = 'post',\n  PUT = 'put',\n  DELETE = 'delete',\n  PATCH = 'patch',\n  HEAD = 'head',\n  OPTIONS = 'options',\n}\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nimport { HttpStatus } from '../types';\nimport { SuccessResponse, ErrorResponse } from './types';\n\nclass RuntimeActionResponse {\n  /**\n   * Returns a success response object, this method should be called on the handlers actions\n   *\n   * @param response a descriptive message of the result\n   *        e.g. 'missing xyz parameter'\n   * @param headers optional headers to include in the response\n   * @returns the response object, ready to be returned from the action main's function.\n   */\n  static success(\n    response: object | string,\n    headers: { [key: string]: string } = {}\n  ): SuccessResponse {\n    return {\n      statusCode: HttpStatus.OK,\n      body: response,\n      headers: headers,\n    };\n  }\n\n  /**\n   * Returns an error response object, this method should be called on the handlers actions\n   *\n   * @param statusCode the status code.\n   *        e.g. 400\n   * @param error a descriptive message of the result\n   *        e.g. 'missing xyz parameter'\n   * @returns the response object, ready to be returned from the action main's function.\n   */\n  static error(statusCode: HttpStatus, error: string): ErrorResponse {\n    return {\n      error: {\n        statusCode,\n        body: {\n          error: error,\n        },\n      },\n    };\n  }\n}\n\nexport default RuntimeActionResponse;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nclass Parameters {\n  /**\n   * Returns a log-ready string of the action input parameters.\n   * The `Authorization` header content will be replaced by '<hidden>'.\n   *\n   * @param params action input parameters.\n   *\n   * @returns string\n   */\n  static stringify(params: { [key: string]: any }): string {\n    // hide authorization token without overriding params\n    let headers = params.__ow_headers || {};\n    if (headers.authorization) {\n      headers = { ...headers, authorization: '<hidden>' };\n    }\n    return JSON.stringify({ ...params, __ow_headers: headers });\n  }\n}\n\nexport default Parameters;\n","/**\n * Copyright © Adobe, Inc. All rights reserved.\n */\n\nclass Validator {\n  /**\n   * Returns the list of missing keys given an object and its required keys.\n   * A parameter is missing if its value is undefined or ''.\n   * A value of 0 or null is not considered as missing.\n   *\n   * @param obj object to check.\n   * @param required list of required keys.\n   *        Each element can be multi-level deep using a '.' separator e.g. 'myRequiredObj.myRequiredKey'\n   *\n   * @returns array\n   * @private\n   */\n  static getMissingKeys(obj: { [key: string]: any }, required: string[]): string[] {\n    return required.filter(r => {\n      const splits = r.split('.');\n      const last = splits[splits.length - 1];\n      const traverse = splits.slice(0, -1).reduce((tObj, split) => tObj[split] || {}, obj);\n      return last && (traverse[last] === undefined || traverse[last] === ''); // missing default params are empty string\n    });\n  }\n\n  /**\n   * Returns the list of missing keys given an object and its required keys.\n   * A parameter is missing if its value is undefined or ''.\n   * A value of 0 or null is not considered as missing.\n   *\n   * @param params action input parameters.\n   * @param requiredHeaders list of required input headers.\n   * @param requiredParams list of required input parameters.\n   *        Each element can be multi-level deep using a '.' separator e.g. 'myRequiredObj.myRequiredKey'.\n   *\n   * @returns string|null if the return value is not null, then it holds an error message describing the missing inputs.\n   *\n   */\n  static checkMissingRequestInputs(\n    params: { [key: string]: any },\n    requiredParams: string[] = [],\n    requiredHeaders: string[] = []\n  ): string | null {\n    let errorMessage: string | null = null;\n\n    // input headers are always lowercase\n    requiredHeaders = requiredHeaders.map(h => h.toLowerCase());\n    // normalize header keys to lowercase for case-insensitive comparison\n    const normalizedHeaders = Object.keys(params.__ow_headers || {}).reduce(\n      (acc, key) => {\n        acc[key.toLowerCase()] = params.__ow_headers?.[key];\n        return acc;\n      },\n      {} as { [key: string]: any }\n    );\n    // check for missing headers\n    const missingHeaders = Validator.getMissingKeys(normalizedHeaders, requiredHeaders);\n    if (missingHeaders.length > 0) {\n      errorMessage = `missing header(s) '${missingHeaders.join(', ')}'`;\n    }\n\n    // check for missing parameters\n    const missingParams = Validator.getMissingKeys(params, requiredParams);\n    if (missingParams.length > 0) {\n      if (errorMessage) {\n        errorMessage += ' and ';\n      } else {\n        errorMessage = '';\n      }\n      errorMessage += `missing parameter(s) '${missingParams.join(', ')}'`;\n    }\n\n    return errorMessage;\n  }\n}\n\nexport default Validator;\n"],"mappings":"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","names":["HttpStatus","HttpMethod","errorMessage"]}